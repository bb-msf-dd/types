// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: claim_schema.proto

#ifndef PROTOBUF_INCLUDED_claim_5fschema_2eproto
#define PROTOBUF_INCLUDED_claim_5fschema_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_claim_5fschema_2eproto 

namespace protobuf_claim_5fschema_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_claim_5fschema_2eproto
namespace pb3 {
class Channel;
class ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class Claim;
class ClaimDefaultTypeInternal;
extern ClaimDefaultTypeInternal _Claim_default_instance_;
class Fee;
class FeeDefaultTypeInternal;
extern FeeDefaultTypeInternal _Fee_default_instance_;
class File;
class FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class Stream;
class StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class Video;
class VideoDefaultTypeInternal;
extern VideoDefaultTypeInternal _Video_default_instance_;
}  // namespace pb3
namespace google {
namespace protobuf {
template<> ::pb3::Channel* Arena::CreateMaybeMessage<::pb3::Channel>(Arena*);
template<> ::pb3::Claim* Arena::CreateMaybeMessage<::pb3::Claim>(Arena*);
template<> ::pb3::Fee* Arena::CreateMaybeMessage<::pb3::Fee>(Arena*);
template<> ::pb3::File* Arena::CreateMaybeMessage<::pb3::File>(Arena*);
template<> ::pb3::Stream* Arena::CreateMaybeMessage<::pb3::Stream>(Arena*);
template<> ::pb3::Video* Arena::CreateMaybeMessage<::pb3::Video>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pb3 {

enum Claim_Type {
  Claim_Type_STREAM = 0,
  Claim_Type_CHANNEL = 1,
  Claim_Type_Claim_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Claim_Type_Claim_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Claim_Type_IsValid(int value);
const Claim_Type Claim_Type_Type_MIN = Claim_Type_STREAM;
const Claim_Type Claim_Type_Type_MAX = Claim_Type_CHANNEL;
const int Claim_Type_Type_ARRAYSIZE = Claim_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Claim_Type_descriptor();
inline const ::std::string& Claim_Type_Name(Claim_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Claim_Type_descriptor(), value);
}
inline bool Claim_Type_Parse(
    const ::std::string& name, Claim_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Claim_Type>(
    Claim_Type_descriptor(), name, value);
}
enum Fee_Currency {
  Fee_Currency_LBC = 0,
  Fee_Currency_USD = 1,
  Fee_Currency_Fee_Currency_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Fee_Currency_Fee_Currency_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Fee_Currency_IsValid(int value);
const Fee_Currency Fee_Currency_Currency_MIN = Fee_Currency_LBC;
const Fee_Currency Fee_Currency_Currency_MAX = Fee_Currency_USD;
const int Fee_Currency_Currency_ARRAYSIZE = Fee_Currency_Currency_MAX + 1;

const ::google::protobuf::EnumDescriptor* Fee_Currency_descriptor();
inline const ::std::string& Fee_Currency_Name(Fee_Currency value) {
  return ::google::protobuf::internal::NameOfEnum(
    Fee_Currency_descriptor(), value);
}
inline bool Fee_Currency_Parse(
    const ::std::string& name, Fee_Currency* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Fee_Currency>(
    Fee_Currency_descriptor(), name, value);
}
// ===================================================================

class Claim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb3.Claim) */ {
 public:
  Claim();
  virtual ~Claim();

  Claim(const Claim& from);

  inline Claim& operator=(const Claim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Claim(Claim&& from) noexcept
    : Claim() {
    *this = ::std::move(from);
  }

  inline Claim& operator=(Claim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Claim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Claim* internal_default_instance() {
    return reinterpret_cast<const Claim*>(
               &_Claim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Claim* other);
  friend void swap(Claim& a, Claim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Claim* New() const final {
    return CreateMaybeMessage<Claim>(NULL);
  }

  Claim* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Claim>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Claim& from);
  void MergeFrom(const Claim& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Claim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Claim_Type Type;
  static const Type STREAM =
    Claim_Type_STREAM;
  static const Type CHANNEL =
    Claim_Type_CHANNEL;
  static inline bool Type_IsValid(int value) {
    return Claim_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Claim_Type_Type_MIN;
  static const Type Type_MAX =
    Claim_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Claim_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Claim_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Claim_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Claim_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .pb3.Stream stream = 2;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 2;
  private:
  const ::pb3::Stream& _internal_stream() const;
  public:
  const ::pb3::Stream& stream() const;
  ::pb3::Stream* release_stream();
  ::pb3::Stream* mutable_stream();
  void set_allocated_stream(::pb3::Stream* stream);

  // .pb3.Channel channel = 3;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 3;
  private:
  const ::pb3::Channel& _internal_channel() const;
  public:
  const ::pb3::Channel& channel() const;
  ::pb3::Channel* release_channel();
  ::pb3::Channel* mutable_channel();
  void set_allocated_channel(::pb3::Channel* channel);

  // .pb3.Claim.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::pb3::Claim_Type type() const;
  void set_type(::pb3::Claim_Type value);

  // @@protoc_insertion_point(class_scope:pb3.Claim)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pb3::Stream* stream_;
  ::pb3::Channel* channel_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_claim_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Channel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb3.Channel) */ {
 public:
  Channel();
  virtual ~Channel();

  Channel(const Channel& from);

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(Channel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Channel* other);
  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Channel* New() const final {
    return CreateMaybeMessage<Channel>(NULL);
  }

  Channel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Channel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tags = 6;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 6;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // bytes public_key = 1;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // string title = 2;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string contact_email = 4;
  void clear_contact_email();
  static const int kContactEmailFieldNumber = 4;
  const ::std::string& contact_email() const;
  void set_contact_email(const ::std::string& value);
  #if LANG_CXX11
  void set_contact_email(::std::string&& value);
  #endif
  void set_contact_email(const char* value);
  void set_contact_email(const char* value, size_t size);
  ::std::string* mutable_contact_email();
  ::std::string* release_contact_email();
  void set_allocated_contact_email(::std::string* contact_email);

  // string homepage_url = 5;
  void clear_homepage_url();
  static const int kHomepageUrlFieldNumber = 5;
  const ::std::string& homepage_url() const;
  void set_homepage_url(const ::std::string& value);
  #if LANG_CXX11
  void set_homepage_url(::std::string&& value);
  #endif
  void set_homepage_url(const char* value);
  void set_homepage_url(const char* value, size_t size);
  ::std::string* mutable_homepage_url();
  ::std::string* release_homepage_url();
  void set_allocated_homepage_url(::std::string* homepage_url);

  // string thumbnail_url = 16;
  void clear_thumbnail_url();
  static const int kThumbnailUrlFieldNumber = 16;
  const ::std::string& thumbnail_url() const;
  void set_thumbnail_url(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_url(::std::string&& value);
  #endif
  void set_thumbnail_url(const char* value);
  void set_thumbnail_url(const char* value, size_t size);
  ::std::string* mutable_thumbnail_url();
  ::std::string* release_thumbnail_url();
  void set_allocated_thumbnail_url(::std::string* thumbnail_url);

  // string cover_url = 17;
  void clear_cover_url();
  static const int kCoverUrlFieldNumber = 17;
  const ::std::string& cover_url() const;
  void set_cover_url(const ::std::string& value);
  #if LANG_CXX11
  void set_cover_url(::std::string&& value);
  #endif
  void set_cover_url(const char* value);
  void set_cover_url(const char* value, size_t size);
  ::std::string* mutable_cover_url();
  ::std::string* release_cover_url();
  void set_allocated_cover_url(::std::string* cover_url);

  // @@protoc_insertion_point(class_scope:pb3.Channel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr contact_email_;
  ::google::protobuf::internal::ArenaStringPtr homepage_url_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_url_;
  ::google::protobuf::internal::ArenaStringPtr cover_url_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_claim_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb3.Stream) */ {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(Stream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Stream* other);
  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Stream* New() const final {
    return CreateMaybeMessage<Stream>(NULL);
  }

  Stream* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Stream>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tags = 20;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 20;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // string language = 2;
  void clear_language();
  static const int kLanguageFieldNumber = 2;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // string title = 3;
  void clear_title();
  static const int kTitleFieldNumber = 3;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // string author = 4;
  void clear_author();
  static const int kAuthorFieldNumber = 4;
  const ::std::string& author() const;
  void set_author(const ::std::string& value);
  #if LANG_CXX11
  void set_author(::std::string&& value);
  #endif
  void set_author(const char* value);
  void set_author(const char* value, size_t size);
  ::std::string* mutable_author();
  ::std::string* release_author();
  void set_allocated_author(::std::string* author);

  // string description = 5;
  void clear_description();
  static const int kDescriptionFieldNumber = 5;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string media_type = 6;
  void clear_media_type();
  static const int kMediaTypeFieldNumber = 6;
  const ::std::string& media_type() const;
  void set_media_type(const ::std::string& value);
  #if LANG_CXX11
  void set_media_type(::std::string&& value);
  #endif
  void set_media_type(const char* value);
  void set_media_type(const char* value, size_t size);
  ::std::string* mutable_media_type();
  ::std::string* release_media_type();
  void set_allocated_media_type(::std::string* media_type);

  // string license = 7;
  void clear_license();
  static const int kLicenseFieldNumber = 7;
  const ::std::string& license() const;
  void set_license(const ::std::string& value);
  #if LANG_CXX11
  void set_license(::std::string&& value);
  #endif
  void set_license(const char* value);
  void set_license(const char* value, size_t size);
  ::std::string* mutable_license();
  ::std::string* release_license();
  void set_allocated_license(::std::string* license);

  // string license_url = 17;
  void clear_license_url();
  static const int kLicenseUrlFieldNumber = 17;
  const ::std::string& license_url() const;
  void set_license_url(const ::std::string& value);
  #if LANG_CXX11
  void set_license_url(::std::string&& value);
  #endif
  void set_license_url(const char* value);
  void set_license_url(const char* value, size_t size);
  ::std::string* mutable_license_url();
  ::std::string* release_license_url();
  void set_allocated_license_url(::std::string* license_url);

  // string thumbnail_url = 18;
  void clear_thumbnail_url();
  static const int kThumbnailUrlFieldNumber = 18;
  const ::std::string& thumbnail_url() const;
  void set_thumbnail_url(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_url(::std::string&& value);
  #endif
  void set_thumbnail_url(const char* value);
  void set_thumbnail_url(const char* value, size_t size);
  ::std::string* mutable_thumbnail_url();
  ::std::string* release_thumbnail_url();
  void set_allocated_thumbnail_url(::std::string* thumbnail_url);

  // .pb3.File file = 8;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 8;
  private:
  const ::pb3::File& _internal_file() const;
  public:
  const ::pb3::File& file() const;
  ::pb3::File* release_file();
  ::pb3::File* mutable_file();
  void set_allocated_file(::pb3::File* file);

  // .pb3.Fee fee = 16;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 16;
  private:
  const ::pb3::Fee& _internal_fee() const;
  public:
  const ::pb3::Fee& fee() const;
  ::pb3::Fee* release_fee();
  ::pb3::Fee* mutable_fee();
  void set_allocated_fee(::pb3::Fee* fee);

  // .pb3.Video video = 22;
  bool has_video() const;
  void clear_video();
  static const int kVideoFieldNumber = 22;
  private:
  const ::pb3::Video& _internal_video() const;
  public:
  const ::pb3::Video& video() const;
  ::pb3::Video* release_video();
  ::pb3::Video* mutable_video();
  void set_allocated_video(::pb3::Video* video);

  // uint32 duration = 19;
  void clear_duration();
  static const int kDurationFieldNumber = 19;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // int64 release_time = 21;
  void clear_release_time();
  static const int kReleaseTimeFieldNumber = 21;
  ::google::protobuf::int64 release_time() const;
  void set_release_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pb3.Stream)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr author_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr media_type_;
  ::google::protobuf::internal::ArenaStringPtr license_;
  ::google::protobuf::internal::ArenaStringPtr license_url_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_url_;
  ::pb3::File* file_;
  ::pb3::Fee* fee_;
  ::pb3::Video* video_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::int64 release_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_claim_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Fee : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb3.Fee) */ {
 public:
  Fee();
  virtual ~Fee();

  Fee(const Fee& from);

  inline Fee& operator=(const Fee& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fee(Fee&& from) noexcept
    : Fee() {
    *this = ::std::move(from);
  }

  inline Fee& operator=(Fee&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Fee& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fee* internal_default_instance() {
    return reinterpret_cast<const Fee*>(
               &_Fee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Fee* other);
  friend void swap(Fee& a, Fee& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fee* New() const final {
    return CreateMaybeMessage<Fee>(NULL);
  }

  Fee* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Fee>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Fee& from);
  void MergeFrom(const Fee& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fee* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Fee_Currency Currency;
  static const Currency LBC =
    Fee_Currency_LBC;
  static const Currency USD =
    Fee_Currency_USD;
  static inline bool Currency_IsValid(int value) {
    return Fee_Currency_IsValid(value);
  }
  static const Currency Currency_MIN =
    Fee_Currency_Currency_MIN;
  static const Currency Currency_MAX =
    Fee_Currency_Currency_MAX;
  static const int Currency_ARRAYSIZE =
    Fee_Currency_Currency_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Currency_descriptor() {
    return Fee_Currency_descriptor();
  }
  static inline const ::std::string& Currency_Name(Currency value) {
    return Fee_Currency_Name(value);
  }
  static inline bool Currency_Parse(const ::std::string& name,
      Currency* value) {
    return Fee_Currency_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // uint64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // .pb3.Fee.Currency currency = 1;
  void clear_currency();
  static const int kCurrencyFieldNumber = 1;
  ::pb3::Fee_Currency currency() const;
  void set_currency(::pb3::Fee_Currency value);

  // @@protoc_insertion_point(class_scope:pb3.Fee)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint64 amount_;
  int currency_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_claim_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb3.File) */ {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(File* other);
  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline File* New() const final {
    return CreateMaybeMessage<File>(NULL);
  }

  File* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<File>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint64 size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb3.File)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_claim_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Video : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb3.Video) */ {
 public:
  Video();
  virtual ~Video();

  Video(const Video& from);

  inline Video& operator=(const Video& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Video(Video&& from) noexcept
    : Video() {
    *this = ::std::move(from);
  }

  inline Video& operator=(Video&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Video& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Video* internal_default_instance() {
    return reinterpret_cast<const Video*>(
               &_Video_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Video* other);
  friend void swap(Video& a, Video& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Video* New() const final {
    return CreateMaybeMessage<Video>(NULL);
  }

  Video* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Video>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Video& from);
  void MergeFrom(const Video& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Video* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // uint32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb3.Video)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_claim_5fschema_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Claim

// .pb3.Claim.Type type = 1;
inline void Claim::clear_type() {
  type_ = 0;
}
inline ::pb3::Claim_Type Claim::type() const {
  // @@protoc_insertion_point(field_get:pb3.Claim.type)
  return static_cast< ::pb3::Claim_Type >(type_);
}
inline void Claim::set_type(::pb3::Claim_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:pb3.Claim.type)
}

// .pb3.Stream stream = 2;
inline bool Claim::has_stream() const {
  return this != internal_default_instance() && stream_ != NULL;
}
inline void Claim::clear_stream() {
  if (GetArenaNoVirtual() == NULL && stream_ != NULL) {
    delete stream_;
  }
  stream_ = NULL;
}
inline const ::pb3::Stream& Claim::_internal_stream() const {
  return *stream_;
}
inline const ::pb3::Stream& Claim::stream() const {
  const ::pb3::Stream* p = stream_;
  // @@protoc_insertion_point(field_get:pb3.Claim.stream)
  return p != NULL ? *p : *reinterpret_cast<const ::pb3::Stream*>(
      &::pb3::_Stream_default_instance_);
}
inline ::pb3::Stream* Claim::release_stream() {
  // @@protoc_insertion_point(field_release:pb3.Claim.stream)
  
  ::pb3::Stream* temp = stream_;
  stream_ = NULL;
  return temp;
}
inline ::pb3::Stream* Claim::mutable_stream() {
  
  if (stream_ == NULL) {
    auto* p = CreateMaybeMessage<::pb3::Stream>(GetArenaNoVirtual());
    stream_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb3.Claim.stream)
  return stream_;
}
inline void Claim::set_allocated_stream(::pb3::Stream* stream) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stream_;
  }
  if (stream) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stream = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    
  } else {
    
  }
  stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:pb3.Claim.stream)
}

// .pb3.Channel channel = 3;
inline bool Claim::has_channel() const {
  return this != internal_default_instance() && channel_ != NULL;
}
inline void Claim::clear_channel() {
  if (GetArenaNoVirtual() == NULL && channel_ != NULL) {
    delete channel_;
  }
  channel_ = NULL;
}
inline const ::pb3::Channel& Claim::_internal_channel() const {
  return *channel_;
}
inline const ::pb3::Channel& Claim::channel() const {
  const ::pb3::Channel* p = channel_;
  // @@protoc_insertion_point(field_get:pb3.Claim.channel)
  return p != NULL ? *p : *reinterpret_cast<const ::pb3::Channel*>(
      &::pb3::_Channel_default_instance_);
}
inline ::pb3::Channel* Claim::release_channel() {
  // @@protoc_insertion_point(field_release:pb3.Claim.channel)
  
  ::pb3::Channel* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline ::pb3::Channel* Claim::mutable_channel() {
  
  if (channel_ == NULL) {
    auto* p = CreateMaybeMessage<::pb3::Channel>(GetArenaNoVirtual());
    channel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb3.Claim.channel)
  return channel_;
}
inline void Claim::set_allocated_channel(::pb3::Channel* channel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete channel_;
  }
  if (channel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      channel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    
  } else {
    
  }
  channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:pb3.Claim.channel)
}

// -------------------------------------------------------------------

// Channel

// bytes public_key = 1;
inline void Channel::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::public_key() const {
  // @@protoc_insertion_point(field_get:pb3.Channel.public_key)
  return public_key_.GetNoArena();
}
inline void Channel::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Channel.public_key)
}
#if LANG_CXX11
inline void Channel::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Channel.public_key)
}
#endif
inline void Channel::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Channel.public_key)
}
inline void Channel::set_public_key(const void* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Channel.public_key)
}
inline ::std::string* Channel::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Channel.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_public_key() {
  // @@protoc_insertion_point(field_release:pb3.Channel.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:pb3.Channel.public_key)
}

// string title = 2;
inline void Channel::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::title() const {
  // @@protoc_insertion_point(field_get:pb3.Channel.title)
  return title_.GetNoArena();
}
inline void Channel::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Channel.title)
}
#if LANG_CXX11
inline void Channel::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Channel.title)
}
#endif
inline void Channel::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Channel.title)
}
inline void Channel::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Channel.title)
}
inline ::std::string* Channel::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Channel.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_title() {
  // @@protoc_insertion_point(field_release:pb3.Channel.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:pb3.Channel.title)
}

// string description = 3;
inline void Channel::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::description() const {
  // @@protoc_insertion_point(field_get:pb3.Channel.description)
  return description_.GetNoArena();
}
inline void Channel::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Channel.description)
}
#if LANG_CXX11
inline void Channel::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Channel.description)
}
#endif
inline void Channel::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Channel.description)
}
inline void Channel::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Channel.description)
}
inline ::std::string* Channel::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Channel.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_description() {
  // @@protoc_insertion_point(field_release:pb3.Channel.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:pb3.Channel.description)
}

// string contact_email = 4;
inline void Channel::clear_contact_email() {
  contact_email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::contact_email() const {
  // @@protoc_insertion_point(field_get:pb3.Channel.contact_email)
  return contact_email_.GetNoArena();
}
inline void Channel::set_contact_email(const ::std::string& value) {
  
  contact_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Channel.contact_email)
}
#if LANG_CXX11
inline void Channel::set_contact_email(::std::string&& value) {
  
  contact_email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Channel.contact_email)
}
#endif
inline void Channel::set_contact_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  contact_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Channel.contact_email)
}
inline void Channel::set_contact_email(const char* value, size_t size) {
  
  contact_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Channel.contact_email)
}
inline ::std::string* Channel::mutable_contact_email() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Channel.contact_email)
  return contact_email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_contact_email() {
  // @@protoc_insertion_point(field_release:pb3.Channel.contact_email)
  
  return contact_email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_contact_email(::std::string* contact_email) {
  if (contact_email != NULL) {
    
  } else {
    
  }
  contact_email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contact_email);
  // @@protoc_insertion_point(field_set_allocated:pb3.Channel.contact_email)
}

// string homepage_url = 5;
inline void Channel::clear_homepage_url() {
  homepage_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::homepage_url() const {
  // @@protoc_insertion_point(field_get:pb3.Channel.homepage_url)
  return homepage_url_.GetNoArena();
}
inline void Channel::set_homepage_url(const ::std::string& value) {
  
  homepage_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Channel.homepage_url)
}
#if LANG_CXX11
inline void Channel::set_homepage_url(::std::string&& value) {
  
  homepage_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Channel.homepage_url)
}
#endif
inline void Channel::set_homepage_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  homepage_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Channel.homepage_url)
}
inline void Channel::set_homepage_url(const char* value, size_t size) {
  
  homepage_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Channel.homepage_url)
}
inline ::std::string* Channel::mutable_homepage_url() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Channel.homepage_url)
  return homepage_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_homepage_url() {
  // @@protoc_insertion_point(field_release:pb3.Channel.homepage_url)
  
  return homepage_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_homepage_url(::std::string* homepage_url) {
  if (homepage_url != NULL) {
    
  } else {
    
  }
  homepage_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), homepage_url);
  // @@protoc_insertion_point(field_set_allocated:pb3.Channel.homepage_url)
}

// repeated string tags = 6;
inline int Channel::tags_size() const {
  return tags_.size();
}
inline void Channel::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Channel::tags(int index) const {
  // @@protoc_insertion_point(field_get:pb3.Channel.tags)
  return tags_.Get(index);
}
inline ::std::string* Channel::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:pb3.Channel.tags)
  return tags_.Mutable(index);
}
inline void Channel::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb3.Channel.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Channel::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pb3.Channel.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Channel::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb3.Channel.tags)
}
inline void Channel::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb3.Channel.tags)
}
inline ::std::string* Channel::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:pb3.Channel.tags)
  return tags_.Add();
}
inline void Channel::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb3.Channel.tags)
}
#if LANG_CXX11
inline void Channel::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb3.Channel.tags)
}
#endif
inline void Channel::add_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb3.Channel.tags)
}
inline void Channel::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb3.Channel.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Channel::tags() const {
  // @@protoc_insertion_point(field_list:pb3.Channel.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Channel::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:pb3.Channel.tags)
  return &tags_;
}

// string thumbnail_url = 16;
inline void Channel::clear_thumbnail_url() {
  thumbnail_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::thumbnail_url() const {
  // @@protoc_insertion_point(field_get:pb3.Channel.thumbnail_url)
  return thumbnail_url_.GetNoArena();
}
inline void Channel::set_thumbnail_url(const ::std::string& value) {
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Channel.thumbnail_url)
}
#if LANG_CXX11
inline void Channel::set_thumbnail_url(::std::string&& value) {
  
  thumbnail_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Channel.thumbnail_url)
}
#endif
inline void Channel::set_thumbnail_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Channel.thumbnail_url)
}
inline void Channel::set_thumbnail_url(const char* value, size_t size) {
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Channel.thumbnail_url)
}
inline ::std::string* Channel::mutable_thumbnail_url() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Channel.thumbnail_url)
  return thumbnail_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_thumbnail_url() {
  // @@protoc_insertion_point(field_release:pb3.Channel.thumbnail_url)
  
  return thumbnail_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_thumbnail_url(::std::string* thumbnail_url) {
  if (thumbnail_url != NULL) {
    
  } else {
    
  }
  thumbnail_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_url);
  // @@protoc_insertion_point(field_set_allocated:pb3.Channel.thumbnail_url)
}

// string cover_url = 17;
inline void Channel::clear_cover_url() {
  cover_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::cover_url() const {
  // @@protoc_insertion_point(field_get:pb3.Channel.cover_url)
  return cover_url_.GetNoArena();
}
inline void Channel::set_cover_url(const ::std::string& value) {
  
  cover_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Channel.cover_url)
}
#if LANG_CXX11
inline void Channel::set_cover_url(::std::string&& value) {
  
  cover_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Channel.cover_url)
}
#endif
inline void Channel::set_cover_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cover_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Channel.cover_url)
}
inline void Channel::set_cover_url(const char* value, size_t size) {
  
  cover_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Channel.cover_url)
}
inline ::std::string* Channel::mutable_cover_url() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Channel.cover_url)
  return cover_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_cover_url() {
  // @@protoc_insertion_point(field_release:pb3.Channel.cover_url)
  
  return cover_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_cover_url(::std::string* cover_url) {
  if (cover_url != NULL) {
    
  } else {
    
  }
  cover_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cover_url);
  // @@protoc_insertion_point(field_set_allocated:pb3.Channel.cover_url)
}

// -------------------------------------------------------------------

// Stream

// bytes hash = 1;
inline void Stream::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::hash() const {
  // @@protoc_insertion_point(field_get:pb3.Stream.hash)
  return hash_.GetNoArena();
}
inline void Stream::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Stream.hash)
}
#if LANG_CXX11
inline void Stream::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Stream.hash)
}
#endif
inline void Stream::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Stream.hash)
}
inline void Stream::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Stream.hash)
}
inline ::std::string* Stream::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Stream.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_hash() {
  // @@protoc_insertion_point(field_release:pb3.Stream.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.hash)
}

// string language = 2;
inline void Stream::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::language() const {
  // @@protoc_insertion_point(field_get:pb3.Stream.language)
  return language_.GetNoArena();
}
inline void Stream::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Stream.language)
}
#if LANG_CXX11
inline void Stream::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Stream.language)
}
#endif
inline void Stream::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Stream.language)
}
inline void Stream::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Stream.language)
}
inline ::std::string* Stream::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Stream.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_language() {
  // @@protoc_insertion_point(field_release:pb3.Stream.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.language)
}

// string title = 3;
inline void Stream::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::title() const {
  // @@protoc_insertion_point(field_get:pb3.Stream.title)
  return title_.GetNoArena();
}
inline void Stream::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Stream.title)
}
#if LANG_CXX11
inline void Stream::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Stream.title)
}
#endif
inline void Stream::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Stream.title)
}
inline void Stream::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Stream.title)
}
inline ::std::string* Stream::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Stream.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_title() {
  // @@protoc_insertion_point(field_release:pb3.Stream.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.title)
}

// string author = 4;
inline void Stream::clear_author() {
  author_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::author() const {
  // @@protoc_insertion_point(field_get:pb3.Stream.author)
  return author_.GetNoArena();
}
inline void Stream::set_author(const ::std::string& value) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Stream.author)
}
#if LANG_CXX11
inline void Stream::set_author(::std::string&& value) {
  
  author_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Stream.author)
}
#endif
inline void Stream::set_author(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Stream.author)
}
inline void Stream::set_author(const char* value, size_t size) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Stream.author)
}
inline ::std::string* Stream::mutable_author() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Stream.author)
  return author_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_author() {
  // @@protoc_insertion_point(field_release:pb3.Stream.author)
  
  return author_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_author(::std::string* author) {
  if (author != NULL) {
    
  } else {
    
  }
  author_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author);
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.author)
}

// string description = 5;
inline void Stream::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::description() const {
  // @@protoc_insertion_point(field_get:pb3.Stream.description)
  return description_.GetNoArena();
}
inline void Stream::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Stream.description)
}
#if LANG_CXX11
inline void Stream::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Stream.description)
}
#endif
inline void Stream::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Stream.description)
}
inline void Stream::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Stream.description)
}
inline ::std::string* Stream::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Stream.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_description() {
  // @@protoc_insertion_point(field_release:pb3.Stream.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.description)
}

// string media_type = 6;
inline void Stream::clear_media_type() {
  media_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::media_type() const {
  // @@protoc_insertion_point(field_get:pb3.Stream.media_type)
  return media_type_.GetNoArena();
}
inline void Stream::set_media_type(const ::std::string& value) {
  
  media_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Stream.media_type)
}
#if LANG_CXX11
inline void Stream::set_media_type(::std::string&& value) {
  
  media_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Stream.media_type)
}
#endif
inline void Stream::set_media_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  media_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Stream.media_type)
}
inline void Stream::set_media_type(const char* value, size_t size) {
  
  media_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Stream.media_type)
}
inline ::std::string* Stream::mutable_media_type() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Stream.media_type)
  return media_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_media_type() {
  // @@protoc_insertion_point(field_release:pb3.Stream.media_type)
  
  return media_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_media_type(::std::string* media_type) {
  if (media_type != NULL) {
    
  } else {
    
  }
  media_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), media_type);
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.media_type)
}

// string license = 7;
inline void Stream::clear_license() {
  license_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::license() const {
  // @@protoc_insertion_point(field_get:pb3.Stream.license)
  return license_.GetNoArena();
}
inline void Stream::set_license(const ::std::string& value) {
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Stream.license)
}
#if LANG_CXX11
inline void Stream::set_license(::std::string&& value) {
  
  license_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Stream.license)
}
#endif
inline void Stream::set_license(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Stream.license)
}
inline void Stream::set_license(const char* value, size_t size) {
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Stream.license)
}
inline ::std::string* Stream::mutable_license() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Stream.license)
  return license_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_license() {
  // @@protoc_insertion_point(field_release:pb3.Stream.license)
  
  return license_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_license(::std::string* license) {
  if (license != NULL) {
    
  } else {
    
  }
  license_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license);
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.license)
}

// .pb3.File file = 8;
inline bool Stream::has_file() const {
  return this != internal_default_instance() && file_ != NULL;
}
inline void Stream::clear_file() {
  if (GetArenaNoVirtual() == NULL && file_ != NULL) {
    delete file_;
  }
  file_ = NULL;
}
inline const ::pb3::File& Stream::_internal_file() const {
  return *file_;
}
inline const ::pb3::File& Stream::file() const {
  const ::pb3::File* p = file_;
  // @@protoc_insertion_point(field_get:pb3.Stream.file)
  return p != NULL ? *p : *reinterpret_cast<const ::pb3::File*>(
      &::pb3::_File_default_instance_);
}
inline ::pb3::File* Stream::release_file() {
  // @@protoc_insertion_point(field_release:pb3.Stream.file)
  
  ::pb3::File* temp = file_;
  file_ = NULL;
  return temp;
}
inline ::pb3::File* Stream::mutable_file() {
  
  if (file_ == NULL) {
    auto* p = CreateMaybeMessage<::pb3::File>(GetArenaNoVirtual());
    file_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb3.Stream.file)
  return file_;
}
inline void Stream::set_allocated_file(::pb3::File* file) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete file_;
  }
  if (file) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      file = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  file_ = file;
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.file)
}

// .pb3.Fee fee = 16;
inline bool Stream::has_fee() const {
  return this != internal_default_instance() && fee_ != NULL;
}
inline void Stream::clear_fee() {
  if (GetArenaNoVirtual() == NULL && fee_ != NULL) {
    delete fee_;
  }
  fee_ = NULL;
}
inline const ::pb3::Fee& Stream::_internal_fee() const {
  return *fee_;
}
inline const ::pb3::Fee& Stream::fee() const {
  const ::pb3::Fee* p = fee_;
  // @@protoc_insertion_point(field_get:pb3.Stream.fee)
  return p != NULL ? *p : *reinterpret_cast<const ::pb3::Fee*>(
      &::pb3::_Fee_default_instance_);
}
inline ::pb3::Fee* Stream::release_fee() {
  // @@protoc_insertion_point(field_release:pb3.Stream.fee)
  
  ::pb3::Fee* temp = fee_;
  fee_ = NULL;
  return temp;
}
inline ::pb3::Fee* Stream::mutable_fee() {
  
  if (fee_ == NULL) {
    auto* p = CreateMaybeMessage<::pb3::Fee>(GetArenaNoVirtual());
    fee_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb3.Stream.fee)
  return fee_;
}
inline void Stream::set_allocated_fee(::pb3::Fee* fee) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fee_;
  }
  if (fee) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fee = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    
  } else {
    
  }
  fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.fee)
}

// string license_url = 17;
inline void Stream::clear_license_url() {
  license_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::license_url() const {
  // @@protoc_insertion_point(field_get:pb3.Stream.license_url)
  return license_url_.GetNoArena();
}
inline void Stream::set_license_url(const ::std::string& value) {
  
  license_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Stream.license_url)
}
#if LANG_CXX11
inline void Stream::set_license_url(::std::string&& value) {
  
  license_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Stream.license_url)
}
#endif
inline void Stream::set_license_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  license_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Stream.license_url)
}
inline void Stream::set_license_url(const char* value, size_t size) {
  
  license_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Stream.license_url)
}
inline ::std::string* Stream::mutable_license_url() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Stream.license_url)
  return license_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_license_url() {
  // @@protoc_insertion_point(field_release:pb3.Stream.license_url)
  
  return license_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_license_url(::std::string* license_url) {
  if (license_url != NULL) {
    
  } else {
    
  }
  license_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license_url);
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.license_url)
}

// string thumbnail_url = 18;
inline void Stream::clear_thumbnail_url() {
  thumbnail_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::thumbnail_url() const {
  // @@protoc_insertion_point(field_get:pb3.Stream.thumbnail_url)
  return thumbnail_url_.GetNoArena();
}
inline void Stream::set_thumbnail_url(const ::std::string& value) {
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Stream.thumbnail_url)
}
#if LANG_CXX11
inline void Stream::set_thumbnail_url(::std::string&& value) {
  
  thumbnail_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Stream.thumbnail_url)
}
#endif
inline void Stream::set_thumbnail_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Stream.thumbnail_url)
}
inline void Stream::set_thumbnail_url(const char* value, size_t size) {
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Stream.thumbnail_url)
}
inline ::std::string* Stream::mutable_thumbnail_url() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Stream.thumbnail_url)
  return thumbnail_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_thumbnail_url() {
  // @@protoc_insertion_point(field_release:pb3.Stream.thumbnail_url)
  
  return thumbnail_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_thumbnail_url(::std::string* thumbnail_url) {
  if (thumbnail_url != NULL) {
    
  } else {
    
  }
  thumbnail_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_url);
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.thumbnail_url)
}

// uint32 duration = 19;
inline void Stream::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 Stream::duration() const {
  // @@protoc_insertion_point(field_get:pb3.Stream.duration)
  return duration_;
}
inline void Stream::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:pb3.Stream.duration)
}

// repeated string tags = 20;
inline int Stream::tags_size() const {
  return tags_.size();
}
inline void Stream::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Stream::tags(int index) const {
  // @@protoc_insertion_point(field_get:pb3.Stream.tags)
  return tags_.Get(index);
}
inline ::std::string* Stream::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:pb3.Stream.tags)
  return tags_.Mutable(index);
}
inline void Stream::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb3.Stream.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Stream::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pb3.Stream.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Stream::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb3.Stream.tags)
}
inline void Stream::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb3.Stream.tags)
}
inline ::std::string* Stream::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:pb3.Stream.tags)
  return tags_.Add();
}
inline void Stream::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb3.Stream.tags)
}
#if LANG_CXX11
inline void Stream::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb3.Stream.tags)
}
#endif
inline void Stream::add_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb3.Stream.tags)
}
inline void Stream::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb3.Stream.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Stream::tags() const {
  // @@protoc_insertion_point(field_list:pb3.Stream.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Stream::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:pb3.Stream.tags)
  return &tags_;
}

// int64 release_time = 21;
inline void Stream::clear_release_time() {
  release_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Stream::release_time() const {
  // @@protoc_insertion_point(field_get:pb3.Stream.release_time)
  return release_time_;
}
inline void Stream::set_release_time(::google::protobuf::int64 value) {
  
  release_time_ = value;
  // @@protoc_insertion_point(field_set:pb3.Stream.release_time)
}

// .pb3.Video video = 22;
inline bool Stream::has_video() const {
  return this != internal_default_instance() && video_ != NULL;
}
inline void Stream::clear_video() {
  if (GetArenaNoVirtual() == NULL && video_ != NULL) {
    delete video_;
  }
  video_ = NULL;
}
inline const ::pb3::Video& Stream::_internal_video() const {
  return *video_;
}
inline const ::pb3::Video& Stream::video() const {
  const ::pb3::Video* p = video_;
  // @@protoc_insertion_point(field_get:pb3.Stream.video)
  return p != NULL ? *p : *reinterpret_cast<const ::pb3::Video*>(
      &::pb3::_Video_default_instance_);
}
inline ::pb3::Video* Stream::release_video() {
  // @@protoc_insertion_point(field_release:pb3.Stream.video)
  
  ::pb3::Video* temp = video_;
  video_ = NULL;
  return temp;
}
inline ::pb3::Video* Stream::mutable_video() {
  
  if (video_ == NULL) {
    auto* p = CreateMaybeMessage<::pb3::Video>(GetArenaNoVirtual());
    video_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb3.Stream.video)
  return video_;
}
inline void Stream::set_allocated_video(::pb3::Video* video) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete video_;
  }
  if (video) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      video = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, video, submessage_arena);
    }
    
  } else {
    
  }
  video_ = video;
  // @@protoc_insertion_point(field_set_allocated:pb3.Stream.video)
}

// -------------------------------------------------------------------

// Fee

// .pb3.Fee.Currency currency = 1;
inline void Fee::clear_currency() {
  currency_ = 0;
}
inline ::pb3::Fee_Currency Fee::currency() const {
  // @@protoc_insertion_point(field_get:pb3.Fee.currency)
  return static_cast< ::pb3::Fee_Currency >(currency_);
}
inline void Fee::set_currency(::pb3::Fee_Currency value) {
  
  currency_ = value;
  // @@protoc_insertion_point(field_set:pb3.Fee.currency)
}

// bytes address = 2;
inline void Fee::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fee::address() const {
  // @@protoc_insertion_point(field_get:pb3.Fee.address)
  return address_.GetNoArena();
}
inline void Fee::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.Fee.address)
}
#if LANG_CXX11
inline void Fee::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.Fee.address)
}
#endif
inline void Fee::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.Fee.address)
}
inline void Fee::set_address(const void* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.Fee.address)
}
inline ::std::string* Fee::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:pb3.Fee.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fee::release_address() {
  // @@protoc_insertion_point(field_release:pb3.Fee.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fee::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:pb3.Fee.address)
}

// uint64 amount = 3;
inline void Fee::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Fee::amount() const {
  // @@protoc_insertion_point(field_get:pb3.Fee.amount)
  return amount_;
}
inline void Fee::set_amount(::google::protobuf::uint64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:pb3.Fee.amount)
}

// -------------------------------------------------------------------

// File

// string name = 1;
inline void File::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& File::name() const {
  // @@protoc_insertion_point(field_get:pb3.File.name)
  return name_.GetNoArena();
}
inline void File::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb3.File.name)
}
#if LANG_CXX11
inline void File::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb3.File.name)
}
#endif
inline void File::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb3.File.name)
}
inline void File::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb3.File.name)
}
inline ::std::string* File::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:pb3.File.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_name() {
  // @@protoc_insertion_point(field_release:pb3.File.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pb3.File.name)
}

// uint64 size = 2;
inline void File::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 File::size() const {
  // @@protoc_insertion_point(field_get:pb3.File.size)
  return size_;
}
inline void File::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:pb3.File.size)
}

// -------------------------------------------------------------------

// Video

// uint32 width = 1;
inline void Video::clear_width() {
  width_ = 0u;
}
inline ::google::protobuf::uint32 Video::width() const {
  // @@protoc_insertion_point(field_get:pb3.Video.width)
  return width_;
}
inline void Video::set_width(::google::protobuf::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:pb3.Video.width)
}

// uint32 height = 2;
inline void Video::clear_height() {
  height_ = 0u;
}
inline ::google::protobuf::uint32 Video::height() const {
  // @@protoc_insertion_point(field_get:pb3.Video.height)
  return height_;
}
inline void Video::set_height(::google::protobuf::uint32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:pb3.Video.height)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb3

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb3::Claim_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb3::Claim_Type>() {
  return ::pb3::Claim_Type_descriptor();
}
template <> struct is_proto_enum< ::pb3::Fee_Currency> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb3::Fee_Currency>() {
  return ::pb3::Fee_Currency_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_claim_5fschema_2eproto
