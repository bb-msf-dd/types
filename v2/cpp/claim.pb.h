// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: claim.proto

#ifndef PROTOBUF_INCLUDED_claim_2eproto
#define PROTOBUF_INCLUDED_claim_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_claim_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_claim_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_claim_2eproto();
namespace pb {
class Audio;
class AudioDefaultTypeInternal;
extern AudioDefaultTypeInternal _Audio_default_instance_;
class Channel;
class ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class Claim;
class ClaimDefaultTypeInternal;
extern ClaimDefaultTypeInternal _Claim_default_instance_;
class ClaimList;
class ClaimListDefaultTypeInternal;
extern ClaimListDefaultTypeInternal _ClaimList_default_instance_;
class ClaimReference;
class ClaimReferenceDefaultTypeInternal;
extern ClaimReferenceDefaultTypeInternal _ClaimReference_default_instance_;
class Fee;
class FeeDefaultTypeInternal;
extern FeeDefaultTypeInternal _Fee_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Language;
class LanguageDefaultTypeInternal;
extern LanguageDefaultTypeInternal _Language_default_instance_;
class Location;
class LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Software;
class SoftwareDefaultTypeInternal;
extern SoftwareDefaultTypeInternal _Software_default_instance_;
class Source;
class SourceDefaultTypeInternal;
extern SourceDefaultTypeInternal _Source_default_instance_;
class Stream;
class StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class Video;
class VideoDefaultTypeInternal;
extern VideoDefaultTypeInternal _Video_default_instance_;
}  // namespace pb
namespace google {
namespace protobuf {
template<> ::pb::Audio* Arena::CreateMaybeMessage<::pb::Audio>(Arena*);
template<> ::pb::Channel* Arena::CreateMaybeMessage<::pb::Channel>(Arena*);
template<> ::pb::Claim* Arena::CreateMaybeMessage<::pb::Claim>(Arena*);
template<> ::pb::ClaimList* Arena::CreateMaybeMessage<::pb::ClaimList>(Arena*);
template<> ::pb::ClaimReference* Arena::CreateMaybeMessage<::pb::ClaimReference>(Arena*);
template<> ::pb::Fee* Arena::CreateMaybeMessage<::pb::Fee>(Arena*);
template<> ::pb::Image* Arena::CreateMaybeMessage<::pb::Image>(Arena*);
template<> ::pb::Language* Arena::CreateMaybeMessage<::pb::Language>(Arena*);
template<> ::pb::Location* Arena::CreateMaybeMessage<::pb::Location>(Arena*);
template<> ::pb::Software* Arena::CreateMaybeMessage<::pb::Software>(Arena*);
template<> ::pb::Source* Arena::CreateMaybeMessage<::pb::Source>(Arena*);
template<> ::pb::Stream* Arena::CreateMaybeMessage<::pb::Stream>(Arena*);
template<> ::pb::Video* Arena::CreateMaybeMessage<::pb::Video>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pb {

enum ClaimList_ListType {
  ClaimList_ListType_COLLECTION = 0,
  ClaimList_ListType_DERIVATION = 2,
  ClaimList_ListType_ClaimList_ListType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ClaimList_ListType_ClaimList_ListType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ClaimList_ListType_IsValid(int value);
const ClaimList_ListType ClaimList_ListType_ListType_MIN = ClaimList_ListType_COLLECTION;
const ClaimList_ListType ClaimList_ListType_ListType_MAX = ClaimList_ListType_DERIVATION;
const int ClaimList_ListType_ListType_ARRAYSIZE = ClaimList_ListType_ListType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClaimList_ListType_descriptor();
inline const ::std::string& ClaimList_ListType_Name(ClaimList_ListType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClaimList_ListType_descriptor(), value);
}
inline bool ClaimList_ListType_Parse(
    const ::std::string& name, ClaimList_ListType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClaimList_ListType>(
    ClaimList_ListType_descriptor(), name, value);
}
enum Fee_Currency {
  Fee_Currency_UNKNOWN_CURRENCY = 0,
  Fee_Currency_LBC = 1,
  Fee_Currency_BTC = 2,
  Fee_Currency_USD = 3,
  Fee_Currency_Fee_Currency_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Fee_Currency_Fee_Currency_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Fee_Currency_IsValid(int value);
const Fee_Currency Fee_Currency_Currency_MIN = Fee_Currency_UNKNOWN_CURRENCY;
const Fee_Currency Fee_Currency_Currency_MAX = Fee_Currency_USD;
const int Fee_Currency_Currency_ARRAYSIZE = Fee_Currency_Currency_MAX + 1;

const ::google::protobuf::EnumDescriptor* Fee_Currency_descriptor();
inline const ::std::string& Fee_Currency_Name(Fee_Currency value) {
  return ::google::protobuf::internal::NameOfEnum(
    Fee_Currency_descriptor(), value);
}
inline bool Fee_Currency_Parse(
    const ::std::string& name, Fee_Currency* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Fee_Currency>(
    Fee_Currency_descriptor(), name, value);
}
enum Software_OS {
  Software_OS_UNKNOWN_OS = 0,
  Software_OS_ANY = 1,
  Software_OS_LINUX = 2,
  Software_OS_WINDOWS = 3,
  Software_OS_MAC = 4,
  Software_OS_ANDROID = 5,
  Software_OS_IOS = 6,
  Software_OS_Software_OS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Software_OS_Software_OS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Software_OS_IsValid(int value);
const Software_OS Software_OS_OS_MIN = Software_OS_UNKNOWN_OS;
const Software_OS Software_OS_OS_MAX = Software_OS_IOS;
const int Software_OS_OS_ARRAYSIZE = Software_OS_OS_MAX + 1;

const ::google::protobuf::EnumDescriptor* Software_OS_descriptor();
inline const ::std::string& Software_OS_Name(Software_OS value) {
  return ::google::protobuf::internal::NameOfEnum(
    Software_OS_descriptor(), value);
}
inline bool Software_OS_Parse(
    const ::std::string& name, Software_OS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Software_OS>(
    Software_OS_descriptor(), name, value);
}
enum Language_Language {
  Language_Language_UNKNOWN_LANGUAGE = 0,
  Language_Language_en = 1,
  Language_Language_aa = 2,
  Language_Language_ab = 3,
  Language_Language_ae = 4,
  Language_Language_af = 5,
  Language_Language_ak = 6,
  Language_Language_am = 7,
  Language_Language_an = 8,
  Language_Language_ar = 9,
  Language_Language_as = 10,
  Language_Language_av = 11,
  Language_Language_ay = 12,
  Language_Language_az = 13,
  Language_Language_ba = 14,
  Language_Language_be = 15,
  Language_Language_bg = 16,
  Language_Language_bh = 17,
  Language_Language_bi = 18,
  Language_Language_bm = 19,
  Language_Language_bn = 20,
  Language_Language_bo = 21,
  Language_Language_br = 22,
  Language_Language_bs = 23,
  Language_Language_ca = 24,
  Language_Language_ce = 25,
  Language_Language_ch = 26,
  Language_Language_co = 27,
  Language_Language_cr = 28,
  Language_Language_cs = 29,
  Language_Language_cu = 30,
  Language_Language_cv = 31,
  Language_Language_cy = 32,
  Language_Language_da = 33,
  Language_Language_de = 34,
  Language_Language_dv = 35,
  Language_Language_dz = 36,
  Language_Language_ee = 37,
  Language_Language_el = 38,
  Language_Language_eo = 39,
  Language_Language_es = 40,
  Language_Language_et = 41,
  Language_Language_eu = 42,
  Language_Language_fa = 43,
  Language_Language_ff = 44,
  Language_Language_fi = 45,
  Language_Language_fj = 46,
  Language_Language_fo = 47,
  Language_Language_fr = 48,
  Language_Language_fy = 49,
  Language_Language_ga = 50,
  Language_Language_gd = 51,
  Language_Language_gl = 52,
  Language_Language_gn = 53,
  Language_Language_gu = 54,
  Language_Language_gv = 55,
  Language_Language_ha = 56,
  Language_Language_he = 57,
  Language_Language_hi = 58,
  Language_Language_ho = 59,
  Language_Language_hr = 60,
  Language_Language_ht = 61,
  Language_Language_hu = 62,
  Language_Language_hy = 63,
  Language_Language_hz = 64,
  Language_Language_ia = 65,
  Language_Language_id = 66,
  Language_Language_ie = 67,
  Language_Language_ig = 68,
  Language_Language_ii = 69,
  Language_Language_ik = 70,
  Language_Language_io = 71,
  Language_Language_is = 72,
  Language_Language_it = 73,
  Language_Language_iu = 74,
  Language_Language_ja = 75,
  Language_Language_jv = 76,
  Language_Language_ka = 77,
  Language_Language_kg = 78,
  Language_Language_ki = 79,
  Language_Language_kj = 80,
  Language_Language_kk = 81,
  Language_Language_kl = 82,
  Language_Language_km = 83,
  Language_Language_kn = 84,
  Language_Language_ko = 85,
  Language_Language_kr = 86,
  Language_Language_ks = 87,
  Language_Language_ku = 88,
  Language_Language_kv = 89,
  Language_Language_kw = 90,
  Language_Language_ky = 91,
  Language_Language_la = 92,
  Language_Language_lb = 93,
  Language_Language_lg = 94,
  Language_Language_li = 95,
  Language_Language_ln = 96,
  Language_Language_lo = 97,
  Language_Language_lt = 98,
  Language_Language_lu = 99,
  Language_Language_lv = 100,
  Language_Language_mg = 101,
  Language_Language_mh = 102,
  Language_Language_mi = 103,
  Language_Language_mk = 104,
  Language_Language_ml = 105,
  Language_Language_mn = 106,
  Language_Language_mr = 107,
  Language_Language_ms = 108,
  Language_Language_mt = 109,
  Language_Language_my = 110,
  Language_Language_na = 111,
  Language_Language_nb = 112,
  Language_Language_nd = 113,
  Language_Language_ne = 114,
  Language_Language_ng = 115,
  Language_Language_nl = 116,
  Language_Language_nn = 117,
  Language_Language_no = 118,
  Language_Language_nr = 119,
  Language_Language_nv = 120,
  Language_Language_ny = 121,
  Language_Language_oc = 122,
  Language_Language_oj = 123,
  Language_Language_om = 124,
  Language_Language_or_ = 125,
  Language_Language_os = 126,
  Language_Language_pa = 127,
  Language_Language_pi = 128,
  Language_Language_pl = 129,
  Language_Language_ps = 130,
  Language_Language_pt = 131,
  Language_Language_qu = 132,
  Language_Language_rm = 133,
  Language_Language_rn = 134,
  Language_Language_ro = 135,
  Language_Language_ru = 136,
  Language_Language_rw = 137,
  Language_Language_sa = 138,
  Language_Language_sc = 139,
  Language_Language_sd = 140,
  Language_Language_se = 141,
  Language_Language_sg = 142,
  Language_Language_si = 143,
  Language_Language_sk = 144,
  Language_Language_sl = 145,
  Language_Language_sm = 146,
  Language_Language_sn = 147,
  Language_Language_so = 148,
  Language_Language_sq = 149,
  Language_Language_sr = 150,
  Language_Language_ss = 151,
  Language_Language_st = 152,
  Language_Language_su = 153,
  Language_Language_sv = 154,
  Language_Language_sw = 155,
  Language_Language_ta = 156,
  Language_Language_te = 157,
  Language_Language_tg = 158,
  Language_Language_th = 159,
  Language_Language_ti = 160,
  Language_Language_tk = 161,
  Language_Language_tl = 162,
  Language_Language_tn = 163,
  Language_Language_to = 164,
  Language_Language_tr = 165,
  Language_Language_ts = 166,
  Language_Language_tt = 167,
  Language_Language_tw = 168,
  Language_Language_ty = 169,
  Language_Language_ug = 170,
  Language_Language_uk = 171,
  Language_Language_ur = 172,
  Language_Language_uz = 173,
  Language_Language_ve = 174,
  Language_Language_vi = 175,
  Language_Language_vo = 176,
  Language_Language_wa = 177,
  Language_Language_wo = 178,
  Language_Language_xh = 179,
  Language_Language_yi = 180,
  Language_Language_yo = 181,
  Language_Language_za = 182,
  Language_Language_zh = 183,
  Language_Language_zu = 184,
  Language_Language_Language_Language_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Language_Language_Language_Language_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Language_Language_IsValid(int value);
const Language_Language Language_Language_Language_MIN = Language_Language_UNKNOWN_LANGUAGE;
const Language_Language Language_Language_Language_MAX = Language_Language_zu;
const int Language_Language_Language_ARRAYSIZE = Language_Language_Language_MAX + 1;

const ::google::protobuf::EnumDescriptor* Language_Language_descriptor();
inline const ::std::string& Language_Language_Name(Language_Language value) {
  return ::google::protobuf::internal::NameOfEnum(
    Language_Language_descriptor(), value);
}
inline bool Language_Language_Parse(
    const ::std::string& name, Language_Language* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Language_Language>(
    Language_Language_descriptor(), name, value);
}
enum Language_Script {
  Language_Script_UNKNOWN_SCRIPT = 0,
  Language_Script_Adlm = 1,
  Language_Script_Afak = 2,
  Language_Script_Aghb = 3,
  Language_Script_Ahom = 4,
  Language_Script_Arab = 5,
  Language_Script_Aran = 6,
  Language_Script_Armi = 7,
  Language_Script_Armn = 8,
  Language_Script_Avst = 9,
  Language_Script_Bali = 10,
  Language_Script_Bamu = 11,
  Language_Script_Bass = 12,
  Language_Script_Batk = 13,
  Language_Script_Beng = 14,
  Language_Script_Bhks = 15,
  Language_Script_Blis = 16,
  Language_Script_Bopo = 17,
  Language_Script_Brah = 18,
  Language_Script_Brai = 19,
  Language_Script_Bugi = 20,
  Language_Script_Buhd = 21,
  Language_Script_Cakm = 22,
  Language_Script_Cans = 23,
  Language_Script_Cari = 24,
  Language_Script_Cham = 25,
  Language_Script_Cher = 26,
  Language_Script_Cirt = 27,
  Language_Script_Copt = 28,
  Language_Script_Cpmn = 29,
  Language_Script_Cprt = 30,
  Language_Script_Cyrl = 31,
  Language_Script_Cyrs = 32,
  Language_Script_Deva = 33,
  Language_Script_Dogr = 34,
  Language_Script_Dsrt = 35,
  Language_Script_Dupl = 36,
  Language_Script_Egyd = 37,
  Language_Script_Egyh = 38,
  Language_Script_Egyp = 39,
  Language_Script_Elba = 40,
  Language_Script_Elym = 41,
  Language_Script_Ethi = 42,
  Language_Script_Geok = 43,
  Language_Script_Geor = 44,
  Language_Script_Glag = 45,
  Language_Script_Gong = 46,
  Language_Script_Gonm = 47,
  Language_Script_Goth = 48,
  Language_Script_Gran = 49,
  Language_Script_Grek = 50,
  Language_Script_Gujr = 51,
  Language_Script_Guru = 52,
  Language_Script_Hanb = 53,
  Language_Script_Hang = 54,
  Language_Script_Hani = 55,
  Language_Script_Hano = 56,
  Language_Script_Hans = 57,
  Language_Script_Hant = 58,
  Language_Script_Hatr = 59,
  Language_Script_Hebr = 60,
  Language_Script_Hira = 61,
  Language_Script_Hluw = 62,
  Language_Script_Hmng = 63,
  Language_Script_Hmnp = 64,
  Language_Script_Hrkt = 65,
  Language_Script_Hung = 66,
  Language_Script_Inds = 67,
  Language_Script_Ital = 68,
  Language_Script_Jamo = 69,
  Language_Script_Java = 70,
  Language_Script_Jpan = 71,
  Language_Script_Jurc = 72,
  Language_Script_Kali = 73,
  Language_Script_Kana = 74,
  Language_Script_Khar = 75,
  Language_Script_Khmr = 76,
  Language_Script_Khoj = 77,
  Language_Script_Kitl = 78,
  Language_Script_Kits = 79,
  Language_Script_Knda = 80,
  Language_Script_Kore = 81,
  Language_Script_Kpel = 82,
  Language_Script_Kthi = 83,
  Language_Script_Lana = 84,
  Language_Script_Laoo = 85,
  Language_Script_Latf = 86,
  Language_Script_Latg = 87,
  Language_Script_Latn = 88,
  Language_Script_Leke = 89,
  Language_Script_Lepc = 90,
  Language_Script_Limb = 91,
  Language_Script_Lina = 92,
  Language_Script_Linb = 93,
  Language_Script_Lisu = 94,
  Language_Script_Loma = 95,
  Language_Script_Lyci = 96,
  Language_Script_Lydi = 97,
  Language_Script_Mahj = 98,
  Language_Script_Maka = 99,
  Language_Script_Mand = 100,
  Language_Script_Mani = 101,
  Language_Script_Marc = 102,
  Language_Script_Maya = 103,
  Language_Script_Medf = 104,
  Language_Script_Mend = 105,
  Language_Script_Merc = 106,
  Language_Script_Mero = 107,
  Language_Script_Mlym = 108,
  Language_Script_Modi = 109,
  Language_Script_Mong = 110,
  Language_Script_Moon = 111,
  Language_Script_Mroo = 112,
  Language_Script_Mtei = 113,
  Language_Script_Mult = 114,
  Language_Script_Mymr = 115,
  Language_Script_Nand = 116,
  Language_Script_Narb = 117,
  Language_Script_Nbat = 118,
  Language_Script_Newa = 119,
  Language_Script_Nkdb = 120,
  Language_Script_Nkgb = 121,
  Language_Script_Nkoo = 122,
  Language_Script_Nshu = 123,
  Language_Script_Ogam = 124,
  Language_Script_Olck = 125,
  Language_Script_Orkh = 126,
  Language_Script_Orya = 127,
  Language_Script_Osge = 128,
  Language_Script_Osma = 129,
  Language_Script_Palm = 130,
  Language_Script_Pauc = 131,
  Language_Script_Perm = 132,
  Language_Script_Phag = 133,
  Language_Script_Phli = 134,
  Language_Script_Phlp = 135,
  Language_Script_Phlv = 136,
  Language_Script_Phnx = 137,
  Language_Script_Plrd = 138,
  Language_Script_Piqd = 139,
  Language_Script_Prti = 140,
  Language_Script_Qaaa = 141,
  Language_Script_Qabx = 142,
  Language_Script_Rjng = 143,
  Language_Script_Rohg = 144,
  Language_Script_Roro = 145,
  Language_Script_Runr = 146,
  Language_Script_Samr = 147,
  Language_Script_Sara = 148,
  Language_Script_Sarb = 149,
  Language_Script_Saur = 150,
  Language_Script_Sgnw = 151,
  Language_Script_Shaw = 152,
  Language_Script_Shrd = 153,
  Language_Script_Shui = 154,
  Language_Script_Sidd = 155,
  Language_Script_Sind = 156,
  Language_Script_Sinh = 157,
  Language_Script_Sogd = 158,
  Language_Script_Sogo = 159,
  Language_Script_Sora = 160,
  Language_Script_Soyo = 161,
  Language_Script_Sund = 162,
  Language_Script_Sylo = 163,
  Language_Script_Syrc = 164,
  Language_Script_Syre = 165,
  Language_Script_Syrj = 166,
  Language_Script_Syrn = 167,
  Language_Script_Tagb = 168,
  Language_Script_Takr = 169,
  Language_Script_Tale = 170,
  Language_Script_Talu = 171,
  Language_Script_Taml = 172,
  Language_Script_Tang = 173,
  Language_Script_Tavt = 174,
  Language_Script_Telu = 175,
  Language_Script_Teng = 176,
  Language_Script_Tfng = 177,
  Language_Script_Tglg = 178,
  Language_Script_Thaa = 179,
  Language_Script_Thai = 180,
  Language_Script_Tibt = 181,
  Language_Script_Tirh = 182,
  Language_Script_Ugar = 183,
  Language_Script_Vaii = 184,
  Language_Script_Visp = 185,
  Language_Script_Wara = 186,
  Language_Script_Wcho = 187,
  Language_Script_Wole = 188,
  Language_Script_Xpeo = 189,
  Language_Script_Xsux = 190,
  Language_Script_Yiii = 191,
  Language_Script_Zanb = 192,
  Language_Script_Zinh = 193,
  Language_Script_Zmth = 194,
  Language_Script_Zsye = 195,
  Language_Script_Zsym = 196,
  Language_Script_Zxxx = 197,
  Language_Script_Zyyy = 198,
  Language_Script_Zzzz = 199,
  Language_Script_Language_Script_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Language_Script_Language_Script_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Language_Script_IsValid(int value);
const Language_Script Language_Script_Script_MIN = Language_Script_UNKNOWN_SCRIPT;
const Language_Script Language_Script_Script_MAX = Language_Script_Zzzz;
const int Language_Script_Script_ARRAYSIZE = Language_Script_Script_MAX + 1;

const ::google::protobuf::EnumDescriptor* Language_Script_descriptor();
inline const ::std::string& Language_Script_Name(Language_Script value) {
  return ::google::protobuf::internal::NameOfEnum(
    Language_Script_descriptor(), value);
}
inline bool Language_Script_Parse(
    const ::std::string& name, Language_Script* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Language_Script>(
    Language_Script_descriptor(), name, value);
}
enum Location_Country {
  Location_Country_UNKNOWN_COUNTRY = 0,
  Location_Country_AF = 1,
  Location_Country_AX = 2,
  Location_Country_AL = 3,
  Location_Country_DZ = 4,
  Location_Country_AS = 5,
  Location_Country_AD = 6,
  Location_Country_AO = 7,
  Location_Country_AI = 8,
  Location_Country_AQ = 9,
  Location_Country_AG = 10,
  Location_Country_AR = 11,
  Location_Country_AM = 12,
  Location_Country_AW = 13,
  Location_Country_AU = 14,
  Location_Country_AT = 15,
  Location_Country_AZ = 16,
  Location_Country_BS = 17,
  Location_Country_BH = 18,
  Location_Country_BD = 19,
  Location_Country_BB = 20,
  Location_Country_BY = 21,
  Location_Country_BE = 22,
  Location_Country_BZ = 23,
  Location_Country_BJ = 24,
  Location_Country_BM = 25,
  Location_Country_BT = 26,
  Location_Country_BO = 27,
  Location_Country_BQ = 28,
  Location_Country_BA = 29,
  Location_Country_BW = 30,
  Location_Country_BV = 31,
  Location_Country_BR = 32,
  Location_Country_IO = 33,
  Location_Country_BN = 34,
  Location_Country_BG = 35,
  Location_Country_BF = 36,
  Location_Country_BI = 37,
  Location_Country_KH = 38,
  Location_Country_CM = 39,
  Location_Country_CA = 40,
  Location_Country_CV = 41,
  Location_Country_KY = 42,
  Location_Country_CF = 43,
  Location_Country_TD = 44,
  Location_Country_CL = 45,
  Location_Country_CN = 46,
  Location_Country_CX = 47,
  Location_Country_CC = 48,
  Location_Country_CO = 49,
  Location_Country_KM = 50,
  Location_Country_CG = 51,
  Location_Country_CD = 52,
  Location_Country_CK = 53,
  Location_Country_CR = 54,
  Location_Country_CI = 55,
  Location_Country_HR = 56,
  Location_Country_CU = 57,
  Location_Country_CW = 58,
  Location_Country_CY = 59,
  Location_Country_CZ = 60,
  Location_Country_DK = 61,
  Location_Country_DJ = 62,
  Location_Country_DM = 63,
  Location_Country_DO = 64,
  Location_Country_EC = 65,
  Location_Country_EG = 66,
  Location_Country_SV = 67,
  Location_Country_GQ = 68,
  Location_Country_ER = 69,
  Location_Country_EE = 70,
  Location_Country_ET = 71,
  Location_Country_FK = 72,
  Location_Country_FO = 73,
  Location_Country_FJ = 74,
  Location_Country_FI = 75,
  Location_Country_FR = 76,
  Location_Country_GF = 77,
  Location_Country_PF = 78,
  Location_Country_TF = 79,
  Location_Country_GA = 80,
  Location_Country_GM = 81,
  Location_Country_GE = 82,
  Location_Country_DE = 83,
  Location_Country_GH = 84,
  Location_Country_GI = 85,
  Location_Country_GR = 86,
  Location_Country_GL = 87,
  Location_Country_GD = 88,
  Location_Country_GP = 89,
  Location_Country_GU = 90,
  Location_Country_GT = 91,
  Location_Country_GG = 92,
  Location_Country_GN = 93,
  Location_Country_GW = 94,
  Location_Country_GY = 95,
  Location_Country_HT = 96,
  Location_Country_HM = 97,
  Location_Country_VA = 98,
  Location_Country_HN = 99,
  Location_Country_HK = 100,
  Location_Country_HU = 101,
  Location_Country_IS = 102,
  Location_Country_IN = 103,
  Location_Country_ID = 104,
  Location_Country_IR = 105,
  Location_Country_IQ = 106,
  Location_Country_IE = 107,
  Location_Country_IM = 108,
  Location_Country_IL = 109,
  Location_Country_IT = 110,
  Location_Country_JM = 111,
  Location_Country_JP = 112,
  Location_Country_JE = 113,
  Location_Country_JO = 114,
  Location_Country_KZ = 115,
  Location_Country_KE = 116,
  Location_Country_KI = 117,
  Location_Country_KP = 118,
  Location_Country_KR = 119,
  Location_Country_KW = 120,
  Location_Country_KG = 121,
  Location_Country_LA = 122,
  Location_Country_LV = 123,
  Location_Country_LB = 124,
  Location_Country_LS = 125,
  Location_Country_LR = 126,
  Location_Country_LY = 127,
  Location_Country_LI = 128,
  Location_Country_LT = 129,
  Location_Country_LU = 130,
  Location_Country_MO = 131,
  Location_Country_MK = 132,
  Location_Country_MG = 133,
  Location_Country_MW = 134,
  Location_Country_MY = 135,
  Location_Country_MV = 136,
  Location_Country_ML = 137,
  Location_Country_MT = 138,
  Location_Country_MH = 139,
  Location_Country_MQ = 140,
  Location_Country_MR = 141,
  Location_Country_MU = 142,
  Location_Country_YT = 143,
  Location_Country_MX = 144,
  Location_Country_FM = 145,
  Location_Country_MD = 146,
  Location_Country_MC = 147,
  Location_Country_MN = 148,
  Location_Country_ME = 149,
  Location_Country_MS = 150,
  Location_Country_MA = 151,
  Location_Country_MZ = 152,
  Location_Country_MM = 153,
  Location_Country_NA = 154,
  Location_Country_NR = 155,
  Location_Country_NP = 156,
  Location_Country_NL = 157,
  Location_Country_NC = 158,
  Location_Country_NZ = 159,
  Location_Country_NI = 160,
  Location_Country_NE = 161,
  Location_Country_NG = 162,
  Location_Country_NU = 163,
  Location_Country_NF = 164,
  Location_Country_MP = 165,
  Location_Country_NO = 166,
  Location_Country_OM = 167,
  Location_Country_PK = 168,
  Location_Country_PW = 169,
  Location_Country_PS = 170,
  Location_Country_PA = 171,
  Location_Country_PG = 172,
  Location_Country_PY = 173,
  Location_Country_PE = 174,
  Location_Country_PH = 175,
  Location_Country_PN = 176,
  Location_Country_PL = 177,
  Location_Country_PT = 178,
  Location_Country_PR = 179,
  Location_Country_QA = 180,
  Location_Country_RE = 181,
  Location_Country_RO = 182,
  Location_Country_RU = 183,
  Location_Country_RW = 184,
  Location_Country_BL = 185,
  Location_Country_SH = 186,
  Location_Country_KN = 187,
  Location_Country_LC = 188,
  Location_Country_MF = 189,
  Location_Country_PM = 190,
  Location_Country_VC = 191,
  Location_Country_WS = 192,
  Location_Country_SM = 193,
  Location_Country_ST = 194,
  Location_Country_SA = 195,
  Location_Country_SN = 196,
  Location_Country_RS = 197,
  Location_Country_SC = 198,
  Location_Country_SL = 199,
  Location_Country_SG = 200,
  Location_Country_SX = 201,
  Location_Country_SK = 202,
  Location_Country_SI = 203,
  Location_Country_SB = 204,
  Location_Country_SO = 205,
  Location_Country_ZA = 206,
  Location_Country_GS = 207,
  Location_Country_SS = 208,
  Location_Country_ES = 209,
  Location_Country_LK = 210,
  Location_Country_SD = 211,
  Location_Country_SR = 212,
  Location_Country_SJ = 213,
  Location_Country_SZ = 214,
  Location_Country_SE = 215,
  Location_Country_CH = 216,
  Location_Country_SY = 217,
  Location_Country_TW = 218,
  Location_Country_TJ = 219,
  Location_Country_TZ = 220,
  Location_Country_TH = 221,
  Location_Country_TL = 222,
  Location_Country_TG = 223,
  Location_Country_TK = 224,
  Location_Country_TO = 225,
  Location_Country_TT = 226,
  Location_Country_TN = 227,
  Location_Country_TR = 228,
  Location_Country_TM = 229,
  Location_Country_TC = 230,
  Location_Country_TV = 231,
  Location_Country_UG = 232,
  Location_Country_UA = 233,
  Location_Country_AE = 234,
  Location_Country_GB = 235,
  Location_Country_US = 236,
  Location_Country_UM = 237,
  Location_Country_UY = 238,
  Location_Country_UZ = 239,
  Location_Country_VU = 240,
  Location_Country_VE = 241,
  Location_Country_VN = 242,
  Location_Country_VG = 243,
  Location_Country_VI = 244,
  Location_Country_WF = 245,
  Location_Country_EH = 246,
  Location_Country_YE = 247,
  Location_Country_ZM = 248,
  Location_Country_ZW = 249,
  Location_Country_R001 = 250,
  Location_Country_R002 = 251,
  Location_Country_R015 = 252,
  Location_Country_R012 = 253,
  Location_Country_R818 = 254,
  Location_Country_R434 = 255,
  Location_Country_R504 = 256,
  Location_Country_R729 = 257,
  Location_Country_R788 = 258,
  Location_Country_R732 = 259,
  Location_Country_R202 = 260,
  Location_Country_R014 = 261,
  Location_Country_R086 = 262,
  Location_Country_R108 = 263,
  Location_Country_R174 = 264,
  Location_Country_R262 = 265,
  Location_Country_R232 = 266,
  Location_Country_R231 = 267,
  Location_Country_R260 = 268,
  Location_Country_R404 = 269,
  Location_Country_R450 = 270,
  Location_Country_R454 = 271,
  Location_Country_R480 = 272,
  Location_Country_R175 = 273,
  Location_Country_R508 = 274,
  Location_Country_R638 = 275,
  Location_Country_R646 = 276,
  Location_Country_R690 = 277,
  Location_Country_R706 = 278,
  Location_Country_R728 = 279,
  Location_Country_R800 = 280,
  Location_Country_R834 = 281,
  Location_Country_R894 = 282,
  Location_Country_R716 = 283,
  Location_Country_R017 = 284,
  Location_Country_R024 = 285,
  Location_Country_R120 = 286,
  Location_Country_R140 = 287,
  Location_Country_R148 = 288,
  Location_Country_R178 = 289,
  Location_Country_R180 = 290,
  Location_Country_R226 = 291,
  Location_Country_R266 = 292,
  Location_Country_R678 = 293,
  Location_Country_R018 = 294,
  Location_Country_R072 = 295,
  Location_Country_R748 = 296,
  Location_Country_R426 = 297,
  Location_Country_R516 = 298,
  Location_Country_R710 = 299,
  Location_Country_R011 = 300,
  Location_Country_R204 = 301,
  Location_Country_R854 = 302,
  Location_Country_R132 = 303,
  Location_Country_R384 = 304,
  Location_Country_R270 = 305,
  Location_Country_R288 = 306,
  Location_Country_R324 = 307,
  Location_Country_R624 = 308,
  Location_Country_R430 = 309,
  Location_Country_R466 = 310,
  Location_Country_R478 = 311,
  Location_Country_R562 = 312,
  Location_Country_R566 = 313,
  Location_Country_R654 = 314,
  Location_Country_R686 = 315,
  Location_Country_R694 = 316,
  Location_Country_R768 = 317,
  Location_Country_R019 = 318,
  Location_Country_R419 = 319,
  Location_Country_R029 = 320,
  Location_Country_R660 = 321,
  Location_Country_R028 = 322,
  Location_Country_R533 = 323,
  Location_Country_R044 = 324,
  Location_Country_R052 = 325,
  Location_Country_R535 = 326,
  Location_Country_R092 = 327,
  Location_Country_R136 = 328,
  Location_Country_R192 = 329,
  Location_Country_R531 = 330,
  Location_Country_R212 = 331,
  Location_Country_R214 = 332,
  Location_Country_R308 = 333,
  Location_Country_R312 = 334,
  Location_Country_R332 = 335,
  Location_Country_R388 = 336,
  Location_Country_R474 = 337,
  Location_Country_R500 = 338,
  Location_Country_R630 = 339,
  Location_Country_R652 = 340,
  Location_Country_R659 = 341,
  Location_Country_R662 = 342,
  Location_Country_R663 = 343,
  Location_Country_R670 = 344,
  Location_Country_R534 = 345,
  Location_Country_R780 = 346,
  Location_Country_R796 = 347,
  Location_Country_R850 = 348,
  Location_Country_R013 = 349,
  Location_Country_R084 = 350,
  Location_Country_R188 = 351,
  Location_Country_R222 = 352,
  Location_Country_R320 = 353,
  Location_Country_R340 = 354,
  Location_Country_R484 = 355,
  Location_Country_R558 = 356,
  Location_Country_R591 = 357,
  Location_Country_R005 = 358,
  Location_Country_R032 = 359,
  Location_Country_R068 = 360,
  Location_Country_R074 = 361,
  Location_Country_R076 = 362,
  Location_Country_R152 = 363,
  Location_Country_R170 = 364,
  Location_Country_R218 = 365,
  Location_Country_R238 = 366,
  Location_Country_R254 = 367,
  Location_Country_R328 = 368,
  Location_Country_R600 = 369,
  Location_Country_R604 = 370,
  Location_Country_R239 = 371,
  Location_Country_R740 = 372,
  Location_Country_R858 = 373,
  Location_Country_R862 = 374,
  Location_Country_R021 = 375,
  Location_Country_R060 = 376,
  Location_Country_R124 = 377,
  Location_Country_R304 = 378,
  Location_Country_R666 = 379,
  Location_Country_R840 = 380,
  Location_Country_R010 = 381,
  Location_Country_R142 = 382,
  Location_Country_R143 = 383,
  Location_Country_R398 = 384,
  Location_Country_R417 = 385,
  Location_Country_R762 = 386,
  Location_Country_R795 = 387,
  Location_Country_R860 = 388,
  Location_Country_R030 = 389,
  Location_Country_R156 = 390,
  Location_Country_R344 = 391,
  Location_Country_R446 = 392,
  Location_Country_R408 = 393,
  Location_Country_R392 = 394,
  Location_Country_R496 = 395,
  Location_Country_R410 = 396,
  Location_Country_R035 = 397,
  Location_Country_R096 = 398,
  Location_Country_R116 = 399,
  Location_Country_R360 = 400,
  Location_Country_R418 = 401,
  Location_Country_R458 = 402,
  Location_Country_R104 = 403,
  Location_Country_R608 = 404,
  Location_Country_R702 = 405,
  Location_Country_R764 = 406,
  Location_Country_R626 = 407,
  Location_Country_R704 = 408,
  Location_Country_R034 = 409,
  Location_Country_R004 = 410,
  Location_Country_R050 = 411,
  Location_Country_R064 = 412,
  Location_Country_R356 = 413,
  Location_Country_R364 = 414,
  Location_Country_R462 = 415,
  Location_Country_R524 = 416,
  Location_Country_R586 = 417,
  Location_Country_R144 = 418,
  Location_Country_R145 = 419,
  Location_Country_R051 = 420,
  Location_Country_R031 = 421,
  Location_Country_R048 = 422,
  Location_Country_R196 = 423,
  Location_Country_R268 = 424,
  Location_Country_R368 = 425,
  Location_Country_R376 = 426,
  Location_Country_R400 = 427,
  Location_Country_R414 = 428,
  Location_Country_R422 = 429,
  Location_Country_R512 = 430,
  Location_Country_R634 = 431,
  Location_Country_R682 = 432,
  Location_Country_R275 = 433,
  Location_Country_R760 = 434,
  Location_Country_R792 = 435,
  Location_Country_R784 = 436,
  Location_Country_R887 = 437,
  Location_Country_R150 = 438,
  Location_Country_R151 = 439,
  Location_Country_R112 = 440,
  Location_Country_R100 = 441,
  Location_Country_R203 = 442,
  Location_Country_R348 = 443,
  Location_Country_R616 = 444,
  Location_Country_R498 = 445,
  Location_Country_R642 = 446,
  Location_Country_R643 = 447,
  Location_Country_R703 = 448,
  Location_Country_R804 = 449,
  Location_Country_R154 = 450,
  Location_Country_R248 = 451,
  Location_Country_R830 = 452,
  Location_Country_R831 = 453,
  Location_Country_R832 = 454,
  Location_Country_R680 = 455,
  Location_Country_R208 = 456,
  Location_Country_R233 = 457,
  Location_Country_R234 = 458,
  Location_Country_R246 = 459,
  Location_Country_R352 = 460,
  Location_Country_R372 = 461,
  Location_Country_R833 = 462,
  Location_Country_R428 = 463,
  Location_Country_R440 = 464,
  Location_Country_R578 = 465,
  Location_Country_R744 = 466,
  Location_Country_R752 = 467,
  Location_Country_R826 = 468,
  Location_Country_R039 = 469,
  Location_Country_R008 = 470,
  Location_Country_R020 = 471,
  Location_Country_R070 = 472,
  Location_Country_R191 = 473,
  Location_Country_R292 = 474,
  Location_Country_R300 = 475,
  Location_Country_R336 = 476,
  Location_Country_R380 = 477,
  Location_Country_R470 = 478,
  Location_Country_R499 = 479,
  Location_Country_R807 = 480,
  Location_Country_R620 = 481,
  Location_Country_R674 = 482,
  Location_Country_R688 = 483,
  Location_Country_R705 = 484,
  Location_Country_R724 = 485,
  Location_Country_R155 = 486,
  Location_Country_R040 = 487,
  Location_Country_R056 = 488,
  Location_Country_R250 = 489,
  Location_Country_R276 = 490,
  Location_Country_R438 = 491,
  Location_Country_R442 = 492,
  Location_Country_R492 = 493,
  Location_Country_R528 = 494,
  Location_Country_R756 = 495,
  Location_Country_R009 = 496,
  Location_Country_R053 = 497,
  Location_Country_R036 = 498,
  Location_Country_R162 = 499,
  Location_Country_R166 = 500,
  Location_Country_R334 = 501,
  Location_Country_R554 = 502,
  Location_Country_R574 = 503,
  Location_Country_R054 = 504,
  Location_Country_R242 = 505,
  Location_Country_R540 = 506,
  Location_Country_R598 = 507,
  Location_Country_R090 = 508,
  Location_Country_R548 = 509,
  Location_Country_R057 = 510,
  Location_Country_R316 = 511,
  Location_Country_R296 = 512,
  Location_Country_R584 = 513,
  Location_Country_R583 = 514,
  Location_Country_R520 = 515,
  Location_Country_R580 = 516,
  Location_Country_R585 = 517,
  Location_Country_R581 = 518,
  Location_Country_R061 = 519,
  Location_Country_R016 = 520,
  Location_Country_R184 = 521,
  Location_Country_R258 = 522,
  Location_Country_R570 = 523,
  Location_Country_R612 = 524,
  Location_Country_R882 = 525,
  Location_Country_R772 = 526,
  Location_Country_R776 = 527,
  Location_Country_R798 = 528,
  Location_Country_R876 = 529,
  Location_Country_Location_Country_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Location_Country_Location_Country_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Location_Country_IsValid(int value);
const Location_Country Location_Country_Country_MIN = Location_Country_UNKNOWN_COUNTRY;
const Location_Country Location_Country_Country_MAX = Location_Country_R876;
const int Location_Country_Country_ARRAYSIZE = Location_Country_Country_MAX + 1;

const ::google::protobuf::EnumDescriptor* Location_Country_descriptor();
inline const ::std::string& Location_Country_Name(Location_Country value) {
  return ::google::protobuf::internal::NameOfEnum(
    Location_Country_descriptor(), value);
}
inline bool Location_Country_Parse(
    const ::std::string& name, Location_Country* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Location_Country>(
    Location_Country_descriptor(), name, value);
}
// ===================================================================

class Claim final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Claim) */ {
 public:
  Claim();
  virtual ~Claim();

  Claim(const Claim& from);

  inline Claim& operator=(const Claim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Claim(Claim&& from) noexcept
    : Claim() {
    *this = ::std::move(from);
  }

  inline Claim& operator=(Claim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Claim& default_instance();

  enum TypeCase {
    kStream = 1,
    kChannel = 2,
    kCollection = 3,
    kRepost = 4,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Claim* internal_default_instance() {
    return reinterpret_cast<const Claim*>(
               &_Claim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Claim* other);
  friend void swap(Claim& a, Claim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Claim* New() const final {
    return CreateMaybeMessage<Claim>(nullptr);
  }

  Claim* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Claim>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Claim& from);
  void MergeFrom(const Claim& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Claim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tags = 11;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 11;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_tags();

  // repeated .pb.Language languages = 12;
  int languages_size() const;
  void clear_languages();
  static const int kLanguagesFieldNumber = 12;
  ::pb::Language* mutable_languages(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Language >*
      mutable_languages();
  const ::pb::Language& languages(int index) const;
  ::pb::Language* add_languages();
  const ::google::protobuf::RepeatedPtrField< ::pb::Language >&
      languages() const;

  // repeated .pb.Location locations = 13;
  int locations_size() const;
  void clear_locations();
  static const int kLocationsFieldNumber = 13;
  ::pb::Location* mutable_locations(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Location >*
      mutable_locations();
  const ::pb::Location& locations(int index) const;
  ::pb::Location* add_locations();
  const ::google::protobuf::RepeatedPtrField< ::pb::Location >&
      locations() const;

  // string title = 8;
  void clear_title();
  static const int kTitleFieldNumber = 8;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // string description = 9;
  void clear_description();
  static const int kDescriptionFieldNumber = 9;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .pb.Source thumbnail = 10;
  bool has_thumbnail() const;
  void clear_thumbnail();
  static const int kThumbnailFieldNumber = 10;
  const ::pb::Source& thumbnail() const;
  ::pb::Source* release_thumbnail();
  ::pb::Source* mutable_thumbnail();
  void set_allocated_thumbnail(::pb::Source* thumbnail);

  // .pb.Stream stream = 1;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 1;
  const ::pb::Stream& stream() const;
  ::pb::Stream* release_stream();
  ::pb::Stream* mutable_stream();
  void set_allocated_stream(::pb::Stream* stream);

  // .pb.Channel channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  const ::pb::Channel& channel() const;
  ::pb::Channel* release_channel();
  ::pb::Channel* mutable_channel();
  void set_allocated_channel(::pb::Channel* channel);

  // .pb.ClaimList collection = 3;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 3;
  const ::pb::ClaimList& collection() const;
  ::pb::ClaimList* release_collection();
  ::pb::ClaimList* mutable_collection();
  void set_allocated_collection(::pb::ClaimList* collection);

  // .pb.ClaimReference repost = 4;
  bool has_repost() const;
  void clear_repost();
  static const int kRepostFieldNumber = 4;
  const ::pb::ClaimReference& repost() const;
  ::pb::ClaimReference* release_repost();
  ::pb::ClaimReference* mutable_repost();
  void set_allocated_repost(::pb::ClaimReference* repost);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:pb.Claim)
 private:
  class HasBitSetters;
  void set_has_stream();
  void set_has_channel();
  void set_has_collection();
  void set_has_repost();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::pb::Language > languages_;
  ::google::protobuf::RepeatedPtrField< ::pb::Location > locations_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::pb::Source* thumbnail_;
  union TypeUnion {
    TypeUnion() {}
    ::pb::Stream* stream_;
    ::pb::Channel* channel_;
    ::pb::ClaimList* collection_;
    ::pb::ClaimReference* repost_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Stream final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Stream) */ {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(Stream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Stream& default_instance();

  enum TypeCase {
    kImage = 10,
    kVideo = 11,
    kAudio = 12,
    kSoftware = 13,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Stream* other);
  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Stream* New() const final {
    return CreateMaybeMessage<Stream>(nullptr);
  }

  Stream* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Stream>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string author = 2;
  void clear_author();
  static const int kAuthorFieldNumber = 2;
  const ::std::string& author() const;
  void set_author(const ::std::string& value);
  #if LANG_CXX11
  void set_author(::std::string&& value);
  #endif
  void set_author(const char* value);
  void set_author(const char* value, size_t size);
  ::std::string* mutable_author();
  ::std::string* release_author();
  void set_allocated_author(::std::string* author);

  // string license = 3;
  void clear_license();
  static const int kLicenseFieldNumber = 3;
  const ::std::string& license() const;
  void set_license(const ::std::string& value);
  #if LANG_CXX11
  void set_license(::std::string&& value);
  #endif
  void set_license(const char* value);
  void set_license(const char* value, size_t size);
  ::std::string* mutable_license();
  ::std::string* release_license();
  void set_allocated_license(::std::string* license);

  // string license_url = 4;
  void clear_license_url();
  static const int kLicenseUrlFieldNumber = 4;
  const ::std::string& license_url() const;
  void set_license_url(const ::std::string& value);
  #if LANG_CXX11
  void set_license_url(::std::string&& value);
  #endif
  void set_license_url(const char* value);
  void set_license_url(const char* value, size_t size);
  ::std::string* mutable_license_url();
  ::std::string* release_license_url();
  void set_allocated_license_url(::std::string* license_url);

  // .pb.Source source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::pb::Source& source() const;
  ::pb::Source* release_source();
  ::pb::Source* mutable_source();
  void set_allocated_source(::pb::Source* source);

  // .pb.Fee fee = 6;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 6;
  const ::pb::Fee& fee() const;
  ::pb::Fee* release_fee();
  ::pb::Fee* mutable_fee();
  void set_allocated_fee(::pb::Fee* fee);

  // int64 release_time = 5;
  void clear_release_time();
  static const int kReleaseTimeFieldNumber = 5;
  ::google::protobuf::int64 release_time() const;
  void set_release_time(::google::protobuf::int64 value);

  // .pb.Image image = 10;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 10;
  const ::pb::Image& image() const;
  ::pb::Image* release_image();
  ::pb::Image* mutable_image();
  void set_allocated_image(::pb::Image* image);

  // .pb.Video video = 11;
  bool has_video() const;
  void clear_video();
  static const int kVideoFieldNumber = 11;
  const ::pb::Video& video() const;
  ::pb::Video* release_video();
  ::pb::Video* mutable_video();
  void set_allocated_video(::pb::Video* video);

  // .pb.Audio audio = 12;
  bool has_audio() const;
  void clear_audio();
  static const int kAudioFieldNumber = 12;
  const ::pb::Audio& audio() const;
  ::pb::Audio* release_audio();
  ::pb::Audio* mutable_audio();
  void set_allocated_audio(::pb::Audio* audio);

  // .pb.Software software = 13;
  bool has_software() const;
  void clear_software();
  static const int kSoftwareFieldNumber = 13;
  const ::pb::Software& software() const;
  ::pb::Software* release_software();
  ::pb::Software* mutable_software();
  void set_allocated_software(::pb::Software* software);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:pb.Stream)
 private:
  class HasBitSetters;
  void set_has_image();
  void set_has_video();
  void set_has_audio();
  void set_has_software();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr author_;
  ::google::protobuf::internal::ArenaStringPtr license_;
  ::google::protobuf::internal::ArenaStringPtr license_url_;
  ::pb::Source* source_;
  ::pb::Fee* fee_;
  ::google::protobuf::int64 release_time_;
  union TypeUnion {
    TypeUnion() {}
    ::pb::Image* image_;
    ::pb::Video* video_;
    ::pb::Audio* audio_;
    ::pb::Software* software_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Channel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Channel) */ {
 public:
  Channel();
  virtual ~Channel();

  Channel(const Channel& from);

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(Channel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Channel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Channel* other);
  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Channel* New() const final {
    return CreateMaybeMessage<Channel>(nullptr);
  }

  Channel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Channel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes public_key = 1;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // string email = 2;
  void clear_email();
  static const int kEmailFieldNumber = 2;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // string website_url = 3;
  void clear_website_url();
  static const int kWebsiteUrlFieldNumber = 3;
  const ::std::string& website_url() const;
  void set_website_url(const ::std::string& value);
  #if LANG_CXX11
  void set_website_url(::std::string&& value);
  #endif
  void set_website_url(const char* value);
  void set_website_url(const char* value, size_t size);
  ::std::string* mutable_website_url();
  ::std::string* release_website_url();
  void set_allocated_website_url(::std::string* website_url);

  // .pb.Source cover = 4;
  bool has_cover() const;
  void clear_cover();
  static const int kCoverFieldNumber = 4;
  const ::pb::Source& cover() const;
  ::pb::Source* release_cover();
  ::pb::Source* mutable_cover();
  void set_allocated_cover(::pb::Source* cover);

  // .pb.ClaimList featured = 5;
  bool has_featured() const;
  void clear_featured();
  static const int kFeaturedFieldNumber = 5;
  const ::pb::ClaimList& featured() const;
  ::pb::ClaimList* release_featured();
  ::pb::ClaimList* mutable_featured();
  void set_allocated_featured(::pb::ClaimList* featured);

  // @@protoc_insertion_point(class_scope:pb.Channel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr website_url_;
  ::pb::Source* cover_;
  ::pb::ClaimList* featured_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class ClaimReference final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.ClaimReference) */ {
 public:
  ClaimReference();
  virtual ~ClaimReference();

  ClaimReference(const ClaimReference& from);

  inline ClaimReference& operator=(const ClaimReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClaimReference(ClaimReference&& from) noexcept
    : ClaimReference() {
    *this = ::std::move(from);
  }

  inline ClaimReference& operator=(ClaimReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ClaimReference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClaimReference* internal_default_instance() {
    return reinterpret_cast<const ClaimReference*>(
               &_ClaimReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ClaimReference* other);
  friend void swap(ClaimReference& a, ClaimReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClaimReference* New() const final {
    return CreateMaybeMessage<ClaimReference>(nullptr);
  }

  ClaimReference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClaimReference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClaimReference& from);
  void MergeFrom(const ClaimReference& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClaimReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes claim_hash = 1;
  void clear_claim_hash();
  static const int kClaimHashFieldNumber = 1;
  const ::std::string& claim_hash() const;
  void set_claim_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_claim_hash(::std::string&& value);
  #endif
  void set_claim_hash(const char* value);
  void set_claim_hash(const void* value, size_t size);
  ::std::string* mutable_claim_hash();
  ::std::string* release_claim_hash();
  void set_allocated_claim_hash(::std::string* claim_hash);

  // @@protoc_insertion_point(class_scope:pb.ClaimReference)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr claim_hash_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class ClaimList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.ClaimList) */ {
 public:
  ClaimList();
  virtual ~ClaimList();

  ClaimList(const ClaimList& from);

  inline ClaimList& operator=(const ClaimList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClaimList(ClaimList&& from) noexcept
    : ClaimList() {
    *this = ::std::move(from);
  }

  inline ClaimList& operator=(ClaimList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ClaimList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClaimList* internal_default_instance() {
    return reinterpret_cast<const ClaimList*>(
               &_ClaimList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ClaimList* other);
  friend void swap(ClaimList& a, ClaimList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClaimList* New() const final {
    return CreateMaybeMessage<ClaimList>(nullptr);
  }

  ClaimList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClaimList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClaimList& from);
  void MergeFrom(const ClaimList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClaimList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClaimList_ListType ListType;
  static const ListType COLLECTION =
    ClaimList_ListType_COLLECTION;
  static const ListType DERIVATION =
    ClaimList_ListType_DERIVATION;
  static inline bool ListType_IsValid(int value) {
    return ClaimList_ListType_IsValid(value);
  }
  static const ListType ListType_MIN =
    ClaimList_ListType_ListType_MIN;
  static const ListType ListType_MAX =
    ClaimList_ListType_ListType_MAX;
  static const int ListType_ARRAYSIZE =
    ClaimList_ListType_ListType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ListType_descriptor() {
    return ClaimList_ListType_descriptor();
  }
  static inline const ::std::string& ListType_Name(ListType value) {
    return ClaimList_ListType_Name(value);
  }
  static inline bool ListType_Parse(const ::std::string& name,
      ListType* value) {
    return ClaimList_ListType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .pb.ClaimReference claim_references = 2;
  int claim_references_size() const;
  void clear_claim_references();
  static const int kClaimReferencesFieldNumber = 2;
  ::pb::ClaimReference* mutable_claim_references(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::ClaimReference >*
      mutable_claim_references();
  const ::pb::ClaimReference& claim_references(int index) const;
  ::pb::ClaimReference* add_claim_references();
  const ::google::protobuf::RepeatedPtrField< ::pb::ClaimReference >&
      claim_references() const;

  // .pb.ClaimList.ListType list_type = 1;
  void clear_list_type();
  static const int kListTypeFieldNumber = 1;
  ::pb::ClaimList_ListType list_type() const;
  void set_list_type(::pb::ClaimList_ListType value);

  // @@protoc_insertion_point(class_scope:pb.ClaimList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::ClaimReference > claim_references_;
  int list_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Source final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Source) */ {
 public:
  Source();
  virtual ~Source();

  Source(const Source& from);

  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Source(Source&& from) noexcept
    : Source() {
    *this = ::std::move(from);
  }

  inline Source& operator=(Source&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Source& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Source* internal_default_instance() {
    return reinterpret_cast<const Source*>(
               &_Source_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Source* other);
  friend void swap(Source& a, Source& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Source* New() const final {
    return CreateMaybeMessage<Source>(nullptr);
  }

  Source* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Source>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Source& from);
  void MergeFrom(const Source& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Source* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string media_type = 4;
  void clear_media_type();
  static const int kMediaTypeFieldNumber = 4;
  const ::std::string& media_type() const;
  void set_media_type(const ::std::string& value);
  #if LANG_CXX11
  void set_media_type(::std::string&& value);
  #endif
  void set_media_type(const char* value);
  void set_media_type(const char* value, size_t size);
  ::std::string* mutable_media_type();
  ::std::string* release_media_type();
  void set_allocated_media_type(::std::string* media_type);

  // string url = 5;
  void clear_url();
  static const int kUrlFieldNumber = 5;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // bytes sd_hash = 6;
  void clear_sd_hash();
  static const int kSdHashFieldNumber = 6;
  const ::std::string& sd_hash() const;
  void set_sd_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_sd_hash(::std::string&& value);
  #endif
  void set_sd_hash(const char* value);
  void set_sd_hash(const void* value, size_t size);
  ::std::string* mutable_sd_hash();
  ::std::string* release_sd_hash();
  void set_allocated_sd_hash(::std::string* sd_hash);

  // bytes bt_infohash = 7;
  void clear_bt_infohash();
  static const int kBtInfohashFieldNumber = 7;
  const ::std::string& bt_infohash() const;
  void set_bt_infohash(const ::std::string& value);
  #if LANG_CXX11
  void set_bt_infohash(::std::string&& value);
  #endif
  void set_bt_infohash(const char* value);
  void set_bt_infohash(const void* value, size_t size);
  ::std::string* mutable_bt_infohash();
  ::std::string* release_bt_infohash();
  void set_allocated_bt_infohash(::std::string* bt_infohash);

  // uint64 size = 3;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.Source)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr media_type_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr sd_hash_;
  ::google::protobuf::internal::ArenaStringPtr bt_infohash_;
  ::google::protobuf::uint64 size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Fee final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Fee) */ {
 public:
  Fee();
  virtual ~Fee();

  Fee(const Fee& from);

  inline Fee& operator=(const Fee& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fee(Fee&& from) noexcept
    : Fee() {
    *this = ::std::move(from);
  }

  inline Fee& operator=(Fee&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Fee& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fee* internal_default_instance() {
    return reinterpret_cast<const Fee*>(
               &_Fee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Fee* other);
  friend void swap(Fee& a, Fee& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fee* New() const final {
    return CreateMaybeMessage<Fee>(nullptr);
  }

  Fee* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Fee>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Fee& from);
  void MergeFrom(const Fee& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fee* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Fee_Currency Currency;
  static const Currency UNKNOWN_CURRENCY =
    Fee_Currency_UNKNOWN_CURRENCY;
  static const Currency LBC =
    Fee_Currency_LBC;
  static const Currency BTC =
    Fee_Currency_BTC;
  static const Currency USD =
    Fee_Currency_USD;
  static inline bool Currency_IsValid(int value) {
    return Fee_Currency_IsValid(value);
  }
  static const Currency Currency_MIN =
    Fee_Currency_Currency_MIN;
  static const Currency Currency_MAX =
    Fee_Currency_Currency_MAX;
  static const int Currency_ARRAYSIZE =
    Fee_Currency_Currency_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Currency_descriptor() {
    return Fee_Currency_descriptor();
  }
  static inline const ::std::string& Currency_Name(Currency value) {
    return Fee_Currency_Name(value);
  }
  static inline bool Currency_Parse(const ::std::string& name,
      Currency* value) {
    return Fee_Currency_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // uint64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // .pb.Fee.Currency currency = 1;
  void clear_currency();
  static const int kCurrencyFieldNumber = 1;
  ::pb::Fee_Currency currency() const;
  void set_currency(::pb::Fee_Currency value);

  // @@protoc_insertion_point(class_scope:pb.Fee)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint64 amount_;
  int currency_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Image final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(Image&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Image* other);
  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const final {
    return CreateMaybeMessage<Image>(nullptr);
  }

  Image* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // uint32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.Image)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Video final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Video) */ {
 public:
  Video();
  virtual ~Video();

  Video(const Video& from);

  inline Video& operator=(const Video& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Video(Video&& from) noexcept
    : Video() {
    *this = ::std::move(from);
  }

  inline Video& operator=(Video&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Video& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Video* internal_default_instance() {
    return reinterpret_cast<const Video*>(
               &_Video_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Video* other);
  friend void swap(Video& a, Video& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Video* New() const final {
    return CreateMaybeMessage<Video>(nullptr);
  }

  Video* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Video>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Video& from);
  void MergeFrom(const Video& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Video* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pb.Audio audio = 15;
  bool has_audio() const;
  void clear_audio();
  static const int kAudioFieldNumber = 15;
  const ::pb::Audio& audio() const;
  ::pb::Audio* release_audio();
  ::pb::Audio* mutable_audio();
  void set_allocated_audio(::pb::Audio* audio);

  // uint32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // uint32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // uint32 duration = 3;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.Video)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pb::Audio* audio_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Audio final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Audio) */ {
 public:
  Audio();
  virtual ~Audio();

  Audio(const Audio& from);

  inline Audio& operator=(const Audio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Audio(Audio&& from) noexcept
    : Audio() {
    *this = ::std::move(from);
  }

  inline Audio& operator=(Audio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Audio& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Audio* internal_default_instance() {
    return reinterpret_cast<const Audio*>(
               &_Audio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Audio* other);
  friend void swap(Audio& a, Audio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Audio* New() const final {
    return CreateMaybeMessage<Audio>(nullptr);
  }

  Audio* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Audio>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Audio& from);
  void MergeFrom(const Audio& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Audio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 duration = 1;
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.Audio)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Software final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Software) */ {
 public:
  Software();
  virtual ~Software();

  Software(const Software& from);

  inline Software& operator=(const Software& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Software(Software&& from) noexcept
    : Software() {
    *this = ::std::move(from);
  }

  inline Software& operator=(Software&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Software& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Software* internal_default_instance() {
    return reinterpret_cast<const Software*>(
               &_Software_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Software* other);
  friend void swap(Software& a, Software& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Software* New() const final {
    return CreateMaybeMessage<Software>(nullptr);
  }

  Software* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Software>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Software& from);
  void MergeFrom(const Software& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Software* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Software_OS OS;
  static const OS UNKNOWN_OS =
    Software_OS_UNKNOWN_OS;
  static const OS ANY =
    Software_OS_ANY;
  static const OS LINUX =
    Software_OS_LINUX;
  static const OS WINDOWS =
    Software_OS_WINDOWS;
  static const OS MAC =
    Software_OS_MAC;
  static const OS ANDROID =
    Software_OS_ANDROID;
  static const OS IOS =
    Software_OS_IOS;
  static inline bool OS_IsValid(int value) {
    return Software_OS_IsValid(value);
  }
  static const OS OS_MIN =
    Software_OS_OS_MIN;
  static const OS OS_MAX =
    Software_OS_OS_MAX;
  static const int OS_ARRAYSIZE =
    Software_OS_OS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OS_descriptor() {
    return Software_OS_descriptor();
  }
  static inline const ::std::string& OS_Name(OS value) {
    return Software_OS_Name(value);
  }
  static inline bool OS_Parse(const ::std::string& name,
      OS* value) {
    return Software_OS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string os = 1;
  void clear_os();
  static const int kOsFieldNumber = 1;
  const ::std::string& os() const;
  void set_os(const ::std::string& value);
  #if LANG_CXX11
  void set_os(::std::string&& value);
  #endif
  void set_os(const char* value);
  void set_os(const char* value, size_t size);
  ::std::string* mutable_os();
  ::std::string* release_os();
  void set_allocated_os(::std::string* os);

  // @@protoc_insertion_point(class_scope:pb.Software)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr os_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Language final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Language) */ {
 public:
  Language();
  virtual ~Language();

  Language(const Language& from);

  inline Language& operator=(const Language& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Language(Language&& from) noexcept
    : Language() {
    *this = ::std::move(from);
  }

  inline Language& operator=(Language&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Language& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Language* internal_default_instance() {
    return reinterpret_cast<const Language*>(
               &_Language_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Language* other);
  friend void swap(Language& a, Language& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Language* New() const final {
    return CreateMaybeMessage<Language>(nullptr);
  }

  Language* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Language>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Language& from);
  void MergeFrom(const Language& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Language* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Language_Language Language;
  static const Language UNKNOWN_LANGUAGE =
    Language_Language_UNKNOWN_LANGUAGE;
  static const Language en =
    Language_Language_en;
  static const Language aa =
    Language_Language_aa;
  static const Language ab =
    Language_Language_ab;
  static const Language ae =
    Language_Language_ae;
  static const Language af =
    Language_Language_af;
  static const Language ak =
    Language_Language_ak;
  static const Language am =
    Language_Language_am;
  static const Language an =
    Language_Language_an;
  static const Language ar =
    Language_Language_ar;
  static const Language as =
    Language_Language_as;
  static const Language av =
    Language_Language_av;
  static const Language ay =
    Language_Language_ay;
  static const Language az =
    Language_Language_az;
  static const Language ba =
    Language_Language_ba;
  static const Language be =
    Language_Language_be;
  static const Language bg =
    Language_Language_bg;
  static const Language bh =
    Language_Language_bh;
  static const Language bi =
    Language_Language_bi;
  static const Language bm =
    Language_Language_bm;
  static const Language bn =
    Language_Language_bn;
  static const Language bo =
    Language_Language_bo;
  static const Language br =
    Language_Language_br;
  static const Language bs =
    Language_Language_bs;
  static const Language ca =
    Language_Language_ca;
  static const Language ce =
    Language_Language_ce;
  static const Language ch =
    Language_Language_ch;
  static const Language co =
    Language_Language_co;
  static const Language cr =
    Language_Language_cr;
  static const Language cs =
    Language_Language_cs;
  static const Language cu =
    Language_Language_cu;
  static const Language cv =
    Language_Language_cv;
  static const Language cy =
    Language_Language_cy;
  static const Language da =
    Language_Language_da;
  static const Language de =
    Language_Language_de;
  static const Language dv =
    Language_Language_dv;
  static const Language dz =
    Language_Language_dz;
  static const Language ee =
    Language_Language_ee;
  static const Language el =
    Language_Language_el;
  static const Language eo =
    Language_Language_eo;
  static const Language es =
    Language_Language_es;
  static const Language et =
    Language_Language_et;
  static const Language eu =
    Language_Language_eu;
  static const Language fa =
    Language_Language_fa;
  static const Language ff =
    Language_Language_ff;
  static const Language fi =
    Language_Language_fi;
  static const Language fj =
    Language_Language_fj;
  static const Language fo =
    Language_Language_fo;
  static const Language fr =
    Language_Language_fr;
  static const Language fy =
    Language_Language_fy;
  static const Language ga =
    Language_Language_ga;
  static const Language gd =
    Language_Language_gd;
  static const Language gl =
    Language_Language_gl;
  static const Language gn =
    Language_Language_gn;
  static const Language gu =
    Language_Language_gu;
  static const Language gv =
    Language_Language_gv;
  static const Language ha =
    Language_Language_ha;
  static const Language he =
    Language_Language_he;
  static const Language hi =
    Language_Language_hi;
  static const Language ho =
    Language_Language_ho;
  static const Language hr =
    Language_Language_hr;
  static const Language ht =
    Language_Language_ht;
  static const Language hu =
    Language_Language_hu;
  static const Language hy =
    Language_Language_hy;
  static const Language hz =
    Language_Language_hz;
  static const Language ia =
    Language_Language_ia;
  static const Language id =
    Language_Language_id;
  static const Language ie =
    Language_Language_ie;
  static const Language ig =
    Language_Language_ig;
  static const Language ii =
    Language_Language_ii;
  static const Language ik =
    Language_Language_ik;
  static const Language io =
    Language_Language_io;
  static const Language is =
    Language_Language_is;
  static const Language it =
    Language_Language_it;
  static const Language iu =
    Language_Language_iu;
  static const Language ja =
    Language_Language_ja;
  static const Language jv =
    Language_Language_jv;
  static const Language ka =
    Language_Language_ka;
  static const Language kg =
    Language_Language_kg;
  static const Language ki =
    Language_Language_ki;
  static const Language kj =
    Language_Language_kj;
  static const Language kk =
    Language_Language_kk;
  static const Language kl =
    Language_Language_kl;
  static const Language km =
    Language_Language_km;
  static const Language kn =
    Language_Language_kn;
  static const Language ko =
    Language_Language_ko;
  static const Language kr =
    Language_Language_kr;
  static const Language ks =
    Language_Language_ks;
  static const Language ku =
    Language_Language_ku;
  static const Language kv =
    Language_Language_kv;
  static const Language kw =
    Language_Language_kw;
  static const Language ky =
    Language_Language_ky;
  static const Language la =
    Language_Language_la;
  static const Language lb =
    Language_Language_lb;
  static const Language lg =
    Language_Language_lg;
  static const Language li =
    Language_Language_li;
  static const Language ln =
    Language_Language_ln;
  static const Language lo =
    Language_Language_lo;
  static const Language lt =
    Language_Language_lt;
  static const Language lu =
    Language_Language_lu;
  static const Language lv =
    Language_Language_lv;
  static const Language mg =
    Language_Language_mg;
  static const Language mh =
    Language_Language_mh;
  static const Language mi =
    Language_Language_mi;
  static const Language mk =
    Language_Language_mk;
  static const Language ml =
    Language_Language_ml;
  static const Language mn =
    Language_Language_mn;
  static const Language mr =
    Language_Language_mr;
  static const Language ms =
    Language_Language_ms;
  static const Language mt =
    Language_Language_mt;
  static const Language my =
    Language_Language_my;
  static const Language na =
    Language_Language_na;
  static const Language nb =
    Language_Language_nb;
  static const Language nd =
    Language_Language_nd;
  static const Language ne =
    Language_Language_ne;
  static const Language ng =
    Language_Language_ng;
  static const Language nl =
    Language_Language_nl;
  static const Language nn =
    Language_Language_nn;
  static const Language no =
    Language_Language_no;
  static const Language nr =
    Language_Language_nr;
  static const Language nv =
    Language_Language_nv;
  static const Language ny =
    Language_Language_ny;
  static const Language oc =
    Language_Language_oc;
  static const Language oj =
    Language_Language_oj;
  static const Language om =
    Language_Language_om;
  static const Language or_ =
    Language_Language_or_;
  static const Language os =
    Language_Language_os;
  static const Language pa =
    Language_Language_pa;
  static const Language pi =
    Language_Language_pi;
  static const Language pl =
    Language_Language_pl;
  static const Language ps =
    Language_Language_ps;
  static const Language pt =
    Language_Language_pt;
  static const Language qu =
    Language_Language_qu;
  static const Language rm =
    Language_Language_rm;
  static const Language rn =
    Language_Language_rn;
  static const Language ro =
    Language_Language_ro;
  static const Language ru =
    Language_Language_ru;
  static const Language rw =
    Language_Language_rw;
  static const Language sa =
    Language_Language_sa;
  static const Language sc =
    Language_Language_sc;
  static const Language sd =
    Language_Language_sd;
  static const Language se =
    Language_Language_se;
  static const Language sg =
    Language_Language_sg;
  static const Language si =
    Language_Language_si;
  static const Language sk =
    Language_Language_sk;
  static const Language sl =
    Language_Language_sl;
  static const Language sm =
    Language_Language_sm;
  static const Language sn =
    Language_Language_sn;
  static const Language so =
    Language_Language_so;
  static const Language sq =
    Language_Language_sq;
  static const Language sr =
    Language_Language_sr;
  static const Language ss =
    Language_Language_ss;
  static const Language st =
    Language_Language_st;
  static const Language su =
    Language_Language_su;
  static const Language sv =
    Language_Language_sv;
  static const Language sw =
    Language_Language_sw;
  static const Language ta =
    Language_Language_ta;
  static const Language te =
    Language_Language_te;
  static const Language tg =
    Language_Language_tg;
  static const Language th =
    Language_Language_th;
  static const Language ti =
    Language_Language_ti;
  static const Language tk =
    Language_Language_tk;
  static const Language tl =
    Language_Language_tl;
  static const Language tn =
    Language_Language_tn;
  static const Language to =
    Language_Language_to;
  static const Language tr =
    Language_Language_tr;
  static const Language ts =
    Language_Language_ts;
  static const Language tt =
    Language_Language_tt;
  static const Language tw =
    Language_Language_tw;
  static const Language ty =
    Language_Language_ty;
  static const Language ug =
    Language_Language_ug;
  static const Language uk =
    Language_Language_uk;
  static const Language ur =
    Language_Language_ur;
  static const Language uz =
    Language_Language_uz;
  static const Language ve =
    Language_Language_ve;
  static const Language vi =
    Language_Language_vi;
  static const Language vo =
    Language_Language_vo;
  static const Language wa =
    Language_Language_wa;
  static const Language wo =
    Language_Language_wo;
  static const Language xh =
    Language_Language_xh;
  static const Language yi =
    Language_Language_yi;
  static const Language yo =
    Language_Language_yo;
  static const Language za =
    Language_Language_za;
  static const Language zh =
    Language_Language_zh;
  static const Language zu =
    Language_Language_zu;
  static inline bool Language_IsValid(int value) {
    return Language_Language_IsValid(value);
  }
  static const Language Language_MIN =
    Language_Language_Language_MIN;
  static const Language Language_MAX =
    Language_Language_Language_MAX;
  static const int Language_ARRAYSIZE =
    Language_Language_Language_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Language_descriptor() {
    return Language_Language_descriptor();
  }
  static inline const ::std::string& Language_Name(Language value) {
    return Language_Language_Name(value);
  }
  static inline bool Language_Parse(const ::std::string& name,
      Language* value) {
    return Language_Language_Parse(name, value);
  }

  typedef Language_Script Script;
  static const Script UNKNOWN_SCRIPT =
    Language_Script_UNKNOWN_SCRIPT;
  static const Script Adlm =
    Language_Script_Adlm;
  static const Script Afak =
    Language_Script_Afak;
  static const Script Aghb =
    Language_Script_Aghb;
  static const Script Ahom =
    Language_Script_Ahom;
  static const Script Arab =
    Language_Script_Arab;
  static const Script Aran =
    Language_Script_Aran;
  static const Script Armi =
    Language_Script_Armi;
  static const Script Armn =
    Language_Script_Armn;
  static const Script Avst =
    Language_Script_Avst;
  static const Script Bali =
    Language_Script_Bali;
  static const Script Bamu =
    Language_Script_Bamu;
  static const Script Bass =
    Language_Script_Bass;
  static const Script Batk =
    Language_Script_Batk;
  static const Script Beng =
    Language_Script_Beng;
  static const Script Bhks =
    Language_Script_Bhks;
  static const Script Blis =
    Language_Script_Blis;
  static const Script Bopo =
    Language_Script_Bopo;
  static const Script Brah =
    Language_Script_Brah;
  static const Script Brai =
    Language_Script_Brai;
  static const Script Bugi =
    Language_Script_Bugi;
  static const Script Buhd =
    Language_Script_Buhd;
  static const Script Cakm =
    Language_Script_Cakm;
  static const Script Cans =
    Language_Script_Cans;
  static const Script Cari =
    Language_Script_Cari;
  static const Script Cham =
    Language_Script_Cham;
  static const Script Cher =
    Language_Script_Cher;
  static const Script Cirt =
    Language_Script_Cirt;
  static const Script Copt =
    Language_Script_Copt;
  static const Script Cpmn =
    Language_Script_Cpmn;
  static const Script Cprt =
    Language_Script_Cprt;
  static const Script Cyrl =
    Language_Script_Cyrl;
  static const Script Cyrs =
    Language_Script_Cyrs;
  static const Script Deva =
    Language_Script_Deva;
  static const Script Dogr =
    Language_Script_Dogr;
  static const Script Dsrt =
    Language_Script_Dsrt;
  static const Script Dupl =
    Language_Script_Dupl;
  static const Script Egyd =
    Language_Script_Egyd;
  static const Script Egyh =
    Language_Script_Egyh;
  static const Script Egyp =
    Language_Script_Egyp;
  static const Script Elba =
    Language_Script_Elba;
  static const Script Elym =
    Language_Script_Elym;
  static const Script Ethi =
    Language_Script_Ethi;
  static const Script Geok =
    Language_Script_Geok;
  static const Script Geor =
    Language_Script_Geor;
  static const Script Glag =
    Language_Script_Glag;
  static const Script Gong =
    Language_Script_Gong;
  static const Script Gonm =
    Language_Script_Gonm;
  static const Script Goth =
    Language_Script_Goth;
  static const Script Gran =
    Language_Script_Gran;
  static const Script Grek =
    Language_Script_Grek;
  static const Script Gujr =
    Language_Script_Gujr;
  static const Script Guru =
    Language_Script_Guru;
  static const Script Hanb =
    Language_Script_Hanb;
  static const Script Hang =
    Language_Script_Hang;
  static const Script Hani =
    Language_Script_Hani;
  static const Script Hano =
    Language_Script_Hano;
  static const Script Hans =
    Language_Script_Hans;
  static const Script Hant =
    Language_Script_Hant;
  static const Script Hatr =
    Language_Script_Hatr;
  static const Script Hebr =
    Language_Script_Hebr;
  static const Script Hira =
    Language_Script_Hira;
  static const Script Hluw =
    Language_Script_Hluw;
  static const Script Hmng =
    Language_Script_Hmng;
  static const Script Hmnp =
    Language_Script_Hmnp;
  static const Script Hrkt =
    Language_Script_Hrkt;
  static const Script Hung =
    Language_Script_Hung;
  static const Script Inds =
    Language_Script_Inds;
  static const Script Ital =
    Language_Script_Ital;
  static const Script Jamo =
    Language_Script_Jamo;
  static const Script Java =
    Language_Script_Java;
  static const Script Jpan =
    Language_Script_Jpan;
  static const Script Jurc =
    Language_Script_Jurc;
  static const Script Kali =
    Language_Script_Kali;
  static const Script Kana =
    Language_Script_Kana;
  static const Script Khar =
    Language_Script_Khar;
  static const Script Khmr =
    Language_Script_Khmr;
  static const Script Khoj =
    Language_Script_Khoj;
  static const Script Kitl =
    Language_Script_Kitl;
  static const Script Kits =
    Language_Script_Kits;
  static const Script Knda =
    Language_Script_Knda;
  static const Script Kore =
    Language_Script_Kore;
  static const Script Kpel =
    Language_Script_Kpel;
  static const Script Kthi =
    Language_Script_Kthi;
  static const Script Lana =
    Language_Script_Lana;
  static const Script Laoo =
    Language_Script_Laoo;
  static const Script Latf =
    Language_Script_Latf;
  static const Script Latg =
    Language_Script_Latg;
  static const Script Latn =
    Language_Script_Latn;
  static const Script Leke =
    Language_Script_Leke;
  static const Script Lepc =
    Language_Script_Lepc;
  static const Script Limb =
    Language_Script_Limb;
  static const Script Lina =
    Language_Script_Lina;
  static const Script Linb =
    Language_Script_Linb;
  static const Script Lisu =
    Language_Script_Lisu;
  static const Script Loma =
    Language_Script_Loma;
  static const Script Lyci =
    Language_Script_Lyci;
  static const Script Lydi =
    Language_Script_Lydi;
  static const Script Mahj =
    Language_Script_Mahj;
  static const Script Maka =
    Language_Script_Maka;
  static const Script Mand =
    Language_Script_Mand;
  static const Script Mani =
    Language_Script_Mani;
  static const Script Marc =
    Language_Script_Marc;
  static const Script Maya =
    Language_Script_Maya;
  static const Script Medf =
    Language_Script_Medf;
  static const Script Mend =
    Language_Script_Mend;
  static const Script Merc =
    Language_Script_Merc;
  static const Script Mero =
    Language_Script_Mero;
  static const Script Mlym =
    Language_Script_Mlym;
  static const Script Modi =
    Language_Script_Modi;
  static const Script Mong =
    Language_Script_Mong;
  static const Script Moon =
    Language_Script_Moon;
  static const Script Mroo =
    Language_Script_Mroo;
  static const Script Mtei =
    Language_Script_Mtei;
  static const Script Mult =
    Language_Script_Mult;
  static const Script Mymr =
    Language_Script_Mymr;
  static const Script Nand =
    Language_Script_Nand;
  static const Script Narb =
    Language_Script_Narb;
  static const Script Nbat =
    Language_Script_Nbat;
  static const Script Newa =
    Language_Script_Newa;
  static const Script Nkdb =
    Language_Script_Nkdb;
  static const Script Nkgb =
    Language_Script_Nkgb;
  static const Script Nkoo =
    Language_Script_Nkoo;
  static const Script Nshu =
    Language_Script_Nshu;
  static const Script Ogam =
    Language_Script_Ogam;
  static const Script Olck =
    Language_Script_Olck;
  static const Script Orkh =
    Language_Script_Orkh;
  static const Script Orya =
    Language_Script_Orya;
  static const Script Osge =
    Language_Script_Osge;
  static const Script Osma =
    Language_Script_Osma;
  static const Script Palm =
    Language_Script_Palm;
  static const Script Pauc =
    Language_Script_Pauc;
  static const Script Perm =
    Language_Script_Perm;
  static const Script Phag =
    Language_Script_Phag;
  static const Script Phli =
    Language_Script_Phli;
  static const Script Phlp =
    Language_Script_Phlp;
  static const Script Phlv =
    Language_Script_Phlv;
  static const Script Phnx =
    Language_Script_Phnx;
  static const Script Plrd =
    Language_Script_Plrd;
  static const Script Piqd =
    Language_Script_Piqd;
  static const Script Prti =
    Language_Script_Prti;
  static const Script Qaaa =
    Language_Script_Qaaa;
  static const Script Qabx =
    Language_Script_Qabx;
  static const Script Rjng =
    Language_Script_Rjng;
  static const Script Rohg =
    Language_Script_Rohg;
  static const Script Roro =
    Language_Script_Roro;
  static const Script Runr =
    Language_Script_Runr;
  static const Script Samr =
    Language_Script_Samr;
  static const Script Sara =
    Language_Script_Sara;
  static const Script Sarb =
    Language_Script_Sarb;
  static const Script Saur =
    Language_Script_Saur;
  static const Script Sgnw =
    Language_Script_Sgnw;
  static const Script Shaw =
    Language_Script_Shaw;
  static const Script Shrd =
    Language_Script_Shrd;
  static const Script Shui =
    Language_Script_Shui;
  static const Script Sidd =
    Language_Script_Sidd;
  static const Script Sind =
    Language_Script_Sind;
  static const Script Sinh =
    Language_Script_Sinh;
  static const Script Sogd =
    Language_Script_Sogd;
  static const Script Sogo =
    Language_Script_Sogo;
  static const Script Sora =
    Language_Script_Sora;
  static const Script Soyo =
    Language_Script_Soyo;
  static const Script Sund =
    Language_Script_Sund;
  static const Script Sylo =
    Language_Script_Sylo;
  static const Script Syrc =
    Language_Script_Syrc;
  static const Script Syre =
    Language_Script_Syre;
  static const Script Syrj =
    Language_Script_Syrj;
  static const Script Syrn =
    Language_Script_Syrn;
  static const Script Tagb =
    Language_Script_Tagb;
  static const Script Takr =
    Language_Script_Takr;
  static const Script Tale =
    Language_Script_Tale;
  static const Script Talu =
    Language_Script_Talu;
  static const Script Taml =
    Language_Script_Taml;
  static const Script Tang =
    Language_Script_Tang;
  static const Script Tavt =
    Language_Script_Tavt;
  static const Script Telu =
    Language_Script_Telu;
  static const Script Teng =
    Language_Script_Teng;
  static const Script Tfng =
    Language_Script_Tfng;
  static const Script Tglg =
    Language_Script_Tglg;
  static const Script Thaa =
    Language_Script_Thaa;
  static const Script Thai =
    Language_Script_Thai;
  static const Script Tibt =
    Language_Script_Tibt;
  static const Script Tirh =
    Language_Script_Tirh;
  static const Script Ugar =
    Language_Script_Ugar;
  static const Script Vaii =
    Language_Script_Vaii;
  static const Script Visp =
    Language_Script_Visp;
  static const Script Wara =
    Language_Script_Wara;
  static const Script Wcho =
    Language_Script_Wcho;
  static const Script Wole =
    Language_Script_Wole;
  static const Script Xpeo =
    Language_Script_Xpeo;
  static const Script Xsux =
    Language_Script_Xsux;
  static const Script Yiii =
    Language_Script_Yiii;
  static const Script Zanb =
    Language_Script_Zanb;
  static const Script Zinh =
    Language_Script_Zinh;
  static const Script Zmth =
    Language_Script_Zmth;
  static const Script Zsye =
    Language_Script_Zsye;
  static const Script Zsym =
    Language_Script_Zsym;
  static const Script Zxxx =
    Language_Script_Zxxx;
  static const Script Zyyy =
    Language_Script_Zyyy;
  static const Script Zzzz =
    Language_Script_Zzzz;
  static inline bool Script_IsValid(int value) {
    return Language_Script_IsValid(value);
  }
  static const Script Script_MIN =
    Language_Script_Script_MIN;
  static const Script Script_MAX =
    Language_Script_Script_MAX;
  static const int Script_ARRAYSIZE =
    Language_Script_Script_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Script_descriptor() {
    return Language_Script_descriptor();
  }
  static inline const ::std::string& Script_Name(Script value) {
    return Language_Script_Name(value);
  }
  static inline bool Script_Parse(const ::std::string& name,
      Script* value) {
    return Language_Script_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .pb.Language.Language language = 1;
  void clear_language();
  static const int kLanguageFieldNumber = 1;
  ::pb::Language_Language language() const;
  void set_language(::pb::Language_Language value);

  // .pb.Language.Script script = 2;
  void clear_script();
  static const int kScriptFieldNumber = 2;
  ::pb::Language_Script script() const;
  void set_script(::pb::Language_Script value);

  // .pb.Location.Country region = 3;
  void clear_region();
  static const int kRegionFieldNumber = 3;
  ::pb::Location_Country region() const;
  void set_region(::pb::Location_Country value);

  // @@protoc_insertion_point(class_scope:pb.Language)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int language_;
  int script_;
  int region_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Location) */ {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Location* other);
  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Location* New() const final {
    return CreateMaybeMessage<Location>(nullptr);
  }

  Location* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Location_Country Country;
  static const Country UNKNOWN_COUNTRY =
    Location_Country_UNKNOWN_COUNTRY;
  static const Country AF =
    Location_Country_AF;
  static const Country AX =
    Location_Country_AX;
  static const Country AL =
    Location_Country_AL;
  static const Country DZ =
    Location_Country_DZ;
  static const Country AS =
    Location_Country_AS;
  static const Country AD =
    Location_Country_AD;
  static const Country AO =
    Location_Country_AO;
  static const Country AI =
    Location_Country_AI;
  static const Country AQ =
    Location_Country_AQ;
  static const Country AG =
    Location_Country_AG;
  static const Country AR =
    Location_Country_AR;
  static const Country AM =
    Location_Country_AM;
  static const Country AW =
    Location_Country_AW;
  static const Country AU =
    Location_Country_AU;
  static const Country AT =
    Location_Country_AT;
  static const Country AZ =
    Location_Country_AZ;
  static const Country BS =
    Location_Country_BS;
  static const Country BH =
    Location_Country_BH;
  static const Country BD =
    Location_Country_BD;
  static const Country BB =
    Location_Country_BB;
  static const Country BY =
    Location_Country_BY;
  static const Country BE =
    Location_Country_BE;
  static const Country BZ =
    Location_Country_BZ;
  static const Country BJ =
    Location_Country_BJ;
  static const Country BM =
    Location_Country_BM;
  static const Country BT =
    Location_Country_BT;
  static const Country BO =
    Location_Country_BO;
  static const Country BQ =
    Location_Country_BQ;
  static const Country BA =
    Location_Country_BA;
  static const Country BW =
    Location_Country_BW;
  static const Country BV =
    Location_Country_BV;
  static const Country BR =
    Location_Country_BR;
  static const Country IO =
    Location_Country_IO;
  static const Country BN =
    Location_Country_BN;
  static const Country BG =
    Location_Country_BG;
  static const Country BF =
    Location_Country_BF;
  static const Country BI =
    Location_Country_BI;
  static const Country KH =
    Location_Country_KH;
  static const Country CM =
    Location_Country_CM;
  static const Country CA =
    Location_Country_CA;
  static const Country CV =
    Location_Country_CV;
  static const Country KY =
    Location_Country_KY;
  static const Country CF =
    Location_Country_CF;
  static const Country TD =
    Location_Country_TD;
  static const Country CL =
    Location_Country_CL;
  static const Country CN =
    Location_Country_CN;
  static const Country CX =
    Location_Country_CX;
  static const Country CC =
    Location_Country_CC;
  static const Country CO =
    Location_Country_CO;
  static const Country KM =
    Location_Country_KM;
  static const Country CG =
    Location_Country_CG;
  static const Country CD =
    Location_Country_CD;
  static const Country CK =
    Location_Country_CK;
  static const Country CR =
    Location_Country_CR;
  static const Country CI =
    Location_Country_CI;
  static const Country HR =
    Location_Country_HR;
  static const Country CU =
    Location_Country_CU;
  static const Country CW =
    Location_Country_CW;
  static const Country CY =
    Location_Country_CY;
  static const Country CZ =
    Location_Country_CZ;
  static const Country DK =
    Location_Country_DK;
  static const Country DJ =
    Location_Country_DJ;
  static const Country DM =
    Location_Country_DM;
  static const Country DO =
    Location_Country_DO;
  static const Country EC =
    Location_Country_EC;
  static const Country EG =
    Location_Country_EG;
  static const Country SV =
    Location_Country_SV;
  static const Country GQ =
    Location_Country_GQ;
  static const Country ER =
    Location_Country_ER;
  static const Country EE =
    Location_Country_EE;
  static const Country ET =
    Location_Country_ET;
  static const Country FK =
    Location_Country_FK;
  static const Country FO =
    Location_Country_FO;
  static const Country FJ =
    Location_Country_FJ;
  static const Country FI =
    Location_Country_FI;
  static const Country FR =
    Location_Country_FR;
  static const Country GF =
    Location_Country_GF;
  static const Country PF =
    Location_Country_PF;
  static const Country TF =
    Location_Country_TF;
  static const Country GA =
    Location_Country_GA;
  static const Country GM =
    Location_Country_GM;
  static const Country GE =
    Location_Country_GE;
  static const Country DE =
    Location_Country_DE;
  static const Country GH =
    Location_Country_GH;
  static const Country GI =
    Location_Country_GI;
  static const Country GR =
    Location_Country_GR;
  static const Country GL =
    Location_Country_GL;
  static const Country GD =
    Location_Country_GD;
  static const Country GP =
    Location_Country_GP;
  static const Country GU =
    Location_Country_GU;
  static const Country GT =
    Location_Country_GT;
  static const Country GG =
    Location_Country_GG;
  static const Country GN =
    Location_Country_GN;
  static const Country GW =
    Location_Country_GW;
  static const Country GY =
    Location_Country_GY;
  static const Country HT =
    Location_Country_HT;
  static const Country HM =
    Location_Country_HM;
  static const Country VA =
    Location_Country_VA;
  static const Country HN =
    Location_Country_HN;
  static const Country HK =
    Location_Country_HK;
  static const Country HU =
    Location_Country_HU;
  static const Country IS =
    Location_Country_IS;
  static const Country IN =
    Location_Country_IN;
  static const Country ID =
    Location_Country_ID;
  static const Country IR =
    Location_Country_IR;
  static const Country IQ =
    Location_Country_IQ;
  static const Country IE =
    Location_Country_IE;
  static const Country IM =
    Location_Country_IM;
  static const Country IL =
    Location_Country_IL;
  static const Country IT =
    Location_Country_IT;
  static const Country JM =
    Location_Country_JM;
  static const Country JP =
    Location_Country_JP;
  static const Country JE =
    Location_Country_JE;
  static const Country JO =
    Location_Country_JO;
  static const Country KZ =
    Location_Country_KZ;
  static const Country KE =
    Location_Country_KE;
  static const Country KI =
    Location_Country_KI;
  static const Country KP =
    Location_Country_KP;
  static const Country KR =
    Location_Country_KR;
  static const Country KW =
    Location_Country_KW;
  static const Country KG =
    Location_Country_KG;
  static const Country LA =
    Location_Country_LA;
  static const Country LV =
    Location_Country_LV;
  static const Country LB =
    Location_Country_LB;
  static const Country LS =
    Location_Country_LS;
  static const Country LR =
    Location_Country_LR;
  static const Country LY =
    Location_Country_LY;
  static const Country LI =
    Location_Country_LI;
  static const Country LT =
    Location_Country_LT;
  static const Country LU =
    Location_Country_LU;
  static const Country MO =
    Location_Country_MO;
  static const Country MK =
    Location_Country_MK;
  static const Country MG =
    Location_Country_MG;
  static const Country MW =
    Location_Country_MW;
  static const Country MY =
    Location_Country_MY;
  static const Country MV =
    Location_Country_MV;
  static const Country ML =
    Location_Country_ML;
  static const Country MT =
    Location_Country_MT;
  static const Country MH =
    Location_Country_MH;
  static const Country MQ =
    Location_Country_MQ;
  static const Country MR =
    Location_Country_MR;
  static const Country MU =
    Location_Country_MU;
  static const Country YT =
    Location_Country_YT;
  static const Country MX =
    Location_Country_MX;
  static const Country FM =
    Location_Country_FM;
  static const Country MD =
    Location_Country_MD;
  static const Country MC =
    Location_Country_MC;
  static const Country MN =
    Location_Country_MN;
  static const Country ME =
    Location_Country_ME;
  static const Country MS =
    Location_Country_MS;
  static const Country MA =
    Location_Country_MA;
  static const Country MZ =
    Location_Country_MZ;
  static const Country MM =
    Location_Country_MM;
  static const Country NA =
    Location_Country_NA;
  static const Country NR =
    Location_Country_NR;
  static const Country NP =
    Location_Country_NP;
  static const Country NL =
    Location_Country_NL;
  static const Country NC =
    Location_Country_NC;
  static const Country NZ =
    Location_Country_NZ;
  static const Country NI =
    Location_Country_NI;
  static const Country NE =
    Location_Country_NE;
  static const Country NG =
    Location_Country_NG;
  static const Country NU =
    Location_Country_NU;
  static const Country NF =
    Location_Country_NF;
  static const Country MP =
    Location_Country_MP;
  static const Country NO =
    Location_Country_NO;
  static const Country OM =
    Location_Country_OM;
  static const Country PK =
    Location_Country_PK;
  static const Country PW =
    Location_Country_PW;
  static const Country PS =
    Location_Country_PS;
  static const Country PA =
    Location_Country_PA;
  static const Country PG =
    Location_Country_PG;
  static const Country PY =
    Location_Country_PY;
  static const Country PE =
    Location_Country_PE;
  static const Country PH =
    Location_Country_PH;
  static const Country PN =
    Location_Country_PN;
  static const Country PL =
    Location_Country_PL;
  static const Country PT =
    Location_Country_PT;
  static const Country PR =
    Location_Country_PR;
  static const Country QA =
    Location_Country_QA;
  static const Country RE =
    Location_Country_RE;
  static const Country RO =
    Location_Country_RO;
  static const Country RU =
    Location_Country_RU;
  static const Country RW =
    Location_Country_RW;
  static const Country BL =
    Location_Country_BL;
  static const Country SH =
    Location_Country_SH;
  static const Country KN =
    Location_Country_KN;
  static const Country LC =
    Location_Country_LC;
  static const Country MF =
    Location_Country_MF;
  static const Country PM =
    Location_Country_PM;
  static const Country VC =
    Location_Country_VC;
  static const Country WS =
    Location_Country_WS;
  static const Country SM =
    Location_Country_SM;
  static const Country ST =
    Location_Country_ST;
  static const Country SA =
    Location_Country_SA;
  static const Country SN =
    Location_Country_SN;
  static const Country RS =
    Location_Country_RS;
  static const Country SC =
    Location_Country_SC;
  static const Country SL =
    Location_Country_SL;
  static const Country SG =
    Location_Country_SG;
  static const Country SX =
    Location_Country_SX;
  static const Country SK =
    Location_Country_SK;
  static const Country SI =
    Location_Country_SI;
  static const Country SB =
    Location_Country_SB;
  static const Country SO =
    Location_Country_SO;
  static const Country ZA =
    Location_Country_ZA;
  static const Country GS =
    Location_Country_GS;
  static const Country SS =
    Location_Country_SS;
  static const Country ES =
    Location_Country_ES;
  static const Country LK =
    Location_Country_LK;
  static const Country SD =
    Location_Country_SD;
  static const Country SR =
    Location_Country_SR;
  static const Country SJ =
    Location_Country_SJ;
  static const Country SZ =
    Location_Country_SZ;
  static const Country SE =
    Location_Country_SE;
  static const Country CH =
    Location_Country_CH;
  static const Country SY =
    Location_Country_SY;
  static const Country TW =
    Location_Country_TW;
  static const Country TJ =
    Location_Country_TJ;
  static const Country TZ =
    Location_Country_TZ;
  static const Country TH =
    Location_Country_TH;
  static const Country TL =
    Location_Country_TL;
  static const Country TG =
    Location_Country_TG;
  static const Country TK =
    Location_Country_TK;
  static const Country TO =
    Location_Country_TO;
  static const Country TT =
    Location_Country_TT;
  static const Country TN =
    Location_Country_TN;
  static const Country TR =
    Location_Country_TR;
  static const Country TM =
    Location_Country_TM;
  static const Country TC =
    Location_Country_TC;
  static const Country TV =
    Location_Country_TV;
  static const Country UG =
    Location_Country_UG;
  static const Country UA =
    Location_Country_UA;
  static const Country AE =
    Location_Country_AE;
  static const Country GB =
    Location_Country_GB;
  static const Country US =
    Location_Country_US;
  static const Country UM =
    Location_Country_UM;
  static const Country UY =
    Location_Country_UY;
  static const Country UZ =
    Location_Country_UZ;
  static const Country VU =
    Location_Country_VU;
  static const Country VE =
    Location_Country_VE;
  static const Country VN =
    Location_Country_VN;
  static const Country VG =
    Location_Country_VG;
  static const Country VI =
    Location_Country_VI;
  static const Country WF =
    Location_Country_WF;
  static const Country EH =
    Location_Country_EH;
  static const Country YE =
    Location_Country_YE;
  static const Country ZM =
    Location_Country_ZM;
  static const Country ZW =
    Location_Country_ZW;
  static const Country R001 =
    Location_Country_R001;
  static const Country R002 =
    Location_Country_R002;
  static const Country R015 =
    Location_Country_R015;
  static const Country R012 =
    Location_Country_R012;
  static const Country R818 =
    Location_Country_R818;
  static const Country R434 =
    Location_Country_R434;
  static const Country R504 =
    Location_Country_R504;
  static const Country R729 =
    Location_Country_R729;
  static const Country R788 =
    Location_Country_R788;
  static const Country R732 =
    Location_Country_R732;
  static const Country R202 =
    Location_Country_R202;
  static const Country R014 =
    Location_Country_R014;
  static const Country R086 =
    Location_Country_R086;
  static const Country R108 =
    Location_Country_R108;
  static const Country R174 =
    Location_Country_R174;
  static const Country R262 =
    Location_Country_R262;
  static const Country R232 =
    Location_Country_R232;
  static const Country R231 =
    Location_Country_R231;
  static const Country R260 =
    Location_Country_R260;
  static const Country R404 =
    Location_Country_R404;
  static const Country R450 =
    Location_Country_R450;
  static const Country R454 =
    Location_Country_R454;
  static const Country R480 =
    Location_Country_R480;
  static const Country R175 =
    Location_Country_R175;
  static const Country R508 =
    Location_Country_R508;
  static const Country R638 =
    Location_Country_R638;
  static const Country R646 =
    Location_Country_R646;
  static const Country R690 =
    Location_Country_R690;
  static const Country R706 =
    Location_Country_R706;
  static const Country R728 =
    Location_Country_R728;
  static const Country R800 =
    Location_Country_R800;
  static const Country R834 =
    Location_Country_R834;
  static const Country R894 =
    Location_Country_R894;
  static const Country R716 =
    Location_Country_R716;
  static const Country R017 =
    Location_Country_R017;
  static const Country R024 =
    Location_Country_R024;
  static const Country R120 =
    Location_Country_R120;
  static const Country R140 =
    Location_Country_R140;
  static const Country R148 =
    Location_Country_R148;
  static const Country R178 =
    Location_Country_R178;
  static const Country R180 =
    Location_Country_R180;
  static const Country R226 =
    Location_Country_R226;
  static const Country R266 =
    Location_Country_R266;
  static const Country R678 =
    Location_Country_R678;
  static const Country R018 =
    Location_Country_R018;
  static const Country R072 =
    Location_Country_R072;
  static const Country R748 =
    Location_Country_R748;
  static const Country R426 =
    Location_Country_R426;
  static const Country R516 =
    Location_Country_R516;
  static const Country R710 =
    Location_Country_R710;
  static const Country R011 =
    Location_Country_R011;
  static const Country R204 =
    Location_Country_R204;
  static const Country R854 =
    Location_Country_R854;
  static const Country R132 =
    Location_Country_R132;
  static const Country R384 =
    Location_Country_R384;
  static const Country R270 =
    Location_Country_R270;
  static const Country R288 =
    Location_Country_R288;
  static const Country R324 =
    Location_Country_R324;
  static const Country R624 =
    Location_Country_R624;
  static const Country R430 =
    Location_Country_R430;
  static const Country R466 =
    Location_Country_R466;
  static const Country R478 =
    Location_Country_R478;
  static const Country R562 =
    Location_Country_R562;
  static const Country R566 =
    Location_Country_R566;
  static const Country R654 =
    Location_Country_R654;
  static const Country R686 =
    Location_Country_R686;
  static const Country R694 =
    Location_Country_R694;
  static const Country R768 =
    Location_Country_R768;
  static const Country R019 =
    Location_Country_R019;
  static const Country R419 =
    Location_Country_R419;
  static const Country R029 =
    Location_Country_R029;
  static const Country R660 =
    Location_Country_R660;
  static const Country R028 =
    Location_Country_R028;
  static const Country R533 =
    Location_Country_R533;
  static const Country R044 =
    Location_Country_R044;
  static const Country R052 =
    Location_Country_R052;
  static const Country R535 =
    Location_Country_R535;
  static const Country R092 =
    Location_Country_R092;
  static const Country R136 =
    Location_Country_R136;
  static const Country R192 =
    Location_Country_R192;
  static const Country R531 =
    Location_Country_R531;
  static const Country R212 =
    Location_Country_R212;
  static const Country R214 =
    Location_Country_R214;
  static const Country R308 =
    Location_Country_R308;
  static const Country R312 =
    Location_Country_R312;
  static const Country R332 =
    Location_Country_R332;
  static const Country R388 =
    Location_Country_R388;
  static const Country R474 =
    Location_Country_R474;
  static const Country R500 =
    Location_Country_R500;
  static const Country R630 =
    Location_Country_R630;
  static const Country R652 =
    Location_Country_R652;
  static const Country R659 =
    Location_Country_R659;
  static const Country R662 =
    Location_Country_R662;
  static const Country R663 =
    Location_Country_R663;
  static const Country R670 =
    Location_Country_R670;
  static const Country R534 =
    Location_Country_R534;
  static const Country R780 =
    Location_Country_R780;
  static const Country R796 =
    Location_Country_R796;
  static const Country R850 =
    Location_Country_R850;
  static const Country R013 =
    Location_Country_R013;
  static const Country R084 =
    Location_Country_R084;
  static const Country R188 =
    Location_Country_R188;
  static const Country R222 =
    Location_Country_R222;
  static const Country R320 =
    Location_Country_R320;
  static const Country R340 =
    Location_Country_R340;
  static const Country R484 =
    Location_Country_R484;
  static const Country R558 =
    Location_Country_R558;
  static const Country R591 =
    Location_Country_R591;
  static const Country R005 =
    Location_Country_R005;
  static const Country R032 =
    Location_Country_R032;
  static const Country R068 =
    Location_Country_R068;
  static const Country R074 =
    Location_Country_R074;
  static const Country R076 =
    Location_Country_R076;
  static const Country R152 =
    Location_Country_R152;
  static const Country R170 =
    Location_Country_R170;
  static const Country R218 =
    Location_Country_R218;
  static const Country R238 =
    Location_Country_R238;
  static const Country R254 =
    Location_Country_R254;
  static const Country R328 =
    Location_Country_R328;
  static const Country R600 =
    Location_Country_R600;
  static const Country R604 =
    Location_Country_R604;
  static const Country R239 =
    Location_Country_R239;
  static const Country R740 =
    Location_Country_R740;
  static const Country R858 =
    Location_Country_R858;
  static const Country R862 =
    Location_Country_R862;
  static const Country R021 =
    Location_Country_R021;
  static const Country R060 =
    Location_Country_R060;
  static const Country R124 =
    Location_Country_R124;
  static const Country R304 =
    Location_Country_R304;
  static const Country R666 =
    Location_Country_R666;
  static const Country R840 =
    Location_Country_R840;
  static const Country R010 =
    Location_Country_R010;
  static const Country R142 =
    Location_Country_R142;
  static const Country R143 =
    Location_Country_R143;
  static const Country R398 =
    Location_Country_R398;
  static const Country R417 =
    Location_Country_R417;
  static const Country R762 =
    Location_Country_R762;
  static const Country R795 =
    Location_Country_R795;
  static const Country R860 =
    Location_Country_R860;
  static const Country R030 =
    Location_Country_R030;
  static const Country R156 =
    Location_Country_R156;
  static const Country R344 =
    Location_Country_R344;
  static const Country R446 =
    Location_Country_R446;
  static const Country R408 =
    Location_Country_R408;
  static const Country R392 =
    Location_Country_R392;
  static const Country R496 =
    Location_Country_R496;
  static const Country R410 =
    Location_Country_R410;
  static const Country R035 =
    Location_Country_R035;
  static const Country R096 =
    Location_Country_R096;
  static const Country R116 =
    Location_Country_R116;
  static const Country R360 =
    Location_Country_R360;
  static const Country R418 =
    Location_Country_R418;
  static const Country R458 =
    Location_Country_R458;
  static const Country R104 =
    Location_Country_R104;
  static const Country R608 =
    Location_Country_R608;
  static const Country R702 =
    Location_Country_R702;
  static const Country R764 =
    Location_Country_R764;
  static const Country R626 =
    Location_Country_R626;
  static const Country R704 =
    Location_Country_R704;
  static const Country R034 =
    Location_Country_R034;
  static const Country R004 =
    Location_Country_R004;
  static const Country R050 =
    Location_Country_R050;
  static const Country R064 =
    Location_Country_R064;
  static const Country R356 =
    Location_Country_R356;
  static const Country R364 =
    Location_Country_R364;
  static const Country R462 =
    Location_Country_R462;
  static const Country R524 =
    Location_Country_R524;
  static const Country R586 =
    Location_Country_R586;
  static const Country R144 =
    Location_Country_R144;
  static const Country R145 =
    Location_Country_R145;
  static const Country R051 =
    Location_Country_R051;
  static const Country R031 =
    Location_Country_R031;
  static const Country R048 =
    Location_Country_R048;
  static const Country R196 =
    Location_Country_R196;
  static const Country R268 =
    Location_Country_R268;
  static const Country R368 =
    Location_Country_R368;
  static const Country R376 =
    Location_Country_R376;
  static const Country R400 =
    Location_Country_R400;
  static const Country R414 =
    Location_Country_R414;
  static const Country R422 =
    Location_Country_R422;
  static const Country R512 =
    Location_Country_R512;
  static const Country R634 =
    Location_Country_R634;
  static const Country R682 =
    Location_Country_R682;
  static const Country R275 =
    Location_Country_R275;
  static const Country R760 =
    Location_Country_R760;
  static const Country R792 =
    Location_Country_R792;
  static const Country R784 =
    Location_Country_R784;
  static const Country R887 =
    Location_Country_R887;
  static const Country R150 =
    Location_Country_R150;
  static const Country R151 =
    Location_Country_R151;
  static const Country R112 =
    Location_Country_R112;
  static const Country R100 =
    Location_Country_R100;
  static const Country R203 =
    Location_Country_R203;
  static const Country R348 =
    Location_Country_R348;
  static const Country R616 =
    Location_Country_R616;
  static const Country R498 =
    Location_Country_R498;
  static const Country R642 =
    Location_Country_R642;
  static const Country R643 =
    Location_Country_R643;
  static const Country R703 =
    Location_Country_R703;
  static const Country R804 =
    Location_Country_R804;
  static const Country R154 =
    Location_Country_R154;
  static const Country R248 =
    Location_Country_R248;
  static const Country R830 =
    Location_Country_R830;
  static const Country R831 =
    Location_Country_R831;
  static const Country R832 =
    Location_Country_R832;
  static const Country R680 =
    Location_Country_R680;
  static const Country R208 =
    Location_Country_R208;
  static const Country R233 =
    Location_Country_R233;
  static const Country R234 =
    Location_Country_R234;
  static const Country R246 =
    Location_Country_R246;
  static const Country R352 =
    Location_Country_R352;
  static const Country R372 =
    Location_Country_R372;
  static const Country R833 =
    Location_Country_R833;
  static const Country R428 =
    Location_Country_R428;
  static const Country R440 =
    Location_Country_R440;
  static const Country R578 =
    Location_Country_R578;
  static const Country R744 =
    Location_Country_R744;
  static const Country R752 =
    Location_Country_R752;
  static const Country R826 =
    Location_Country_R826;
  static const Country R039 =
    Location_Country_R039;
  static const Country R008 =
    Location_Country_R008;
  static const Country R020 =
    Location_Country_R020;
  static const Country R070 =
    Location_Country_R070;
  static const Country R191 =
    Location_Country_R191;
  static const Country R292 =
    Location_Country_R292;
  static const Country R300 =
    Location_Country_R300;
  static const Country R336 =
    Location_Country_R336;
  static const Country R380 =
    Location_Country_R380;
  static const Country R470 =
    Location_Country_R470;
  static const Country R499 =
    Location_Country_R499;
  static const Country R807 =
    Location_Country_R807;
  static const Country R620 =
    Location_Country_R620;
  static const Country R674 =
    Location_Country_R674;
  static const Country R688 =
    Location_Country_R688;
  static const Country R705 =
    Location_Country_R705;
  static const Country R724 =
    Location_Country_R724;
  static const Country R155 =
    Location_Country_R155;
  static const Country R040 =
    Location_Country_R040;
  static const Country R056 =
    Location_Country_R056;
  static const Country R250 =
    Location_Country_R250;
  static const Country R276 =
    Location_Country_R276;
  static const Country R438 =
    Location_Country_R438;
  static const Country R442 =
    Location_Country_R442;
  static const Country R492 =
    Location_Country_R492;
  static const Country R528 =
    Location_Country_R528;
  static const Country R756 =
    Location_Country_R756;
  static const Country R009 =
    Location_Country_R009;
  static const Country R053 =
    Location_Country_R053;
  static const Country R036 =
    Location_Country_R036;
  static const Country R162 =
    Location_Country_R162;
  static const Country R166 =
    Location_Country_R166;
  static const Country R334 =
    Location_Country_R334;
  static const Country R554 =
    Location_Country_R554;
  static const Country R574 =
    Location_Country_R574;
  static const Country R054 =
    Location_Country_R054;
  static const Country R242 =
    Location_Country_R242;
  static const Country R540 =
    Location_Country_R540;
  static const Country R598 =
    Location_Country_R598;
  static const Country R090 =
    Location_Country_R090;
  static const Country R548 =
    Location_Country_R548;
  static const Country R057 =
    Location_Country_R057;
  static const Country R316 =
    Location_Country_R316;
  static const Country R296 =
    Location_Country_R296;
  static const Country R584 =
    Location_Country_R584;
  static const Country R583 =
    Location_Country_R583;
  static const Country R520 =
    Location_Country_R520;
  static const Country R580 =
    Location_Country_R580;
  static const Country R585 =
    Location_Country_R585;
  static const Country R581 =
    Location_Country_R581;
  static const Country R061 =
    Location_Country_R061;
  static const Country R016 =
    Location_Country_R016;
  static const Country R184 =
    Location_Country_R184;
  static const Country R258 =
    Location_Country_R258;
  static const Country R570 =
    Location_Country_R570;
  static const Country R612 =
    Location_Country_R612;
  static const Country R882 =
    Location_Country_R882;
  static const Country R772 =
    Location_Country_R772;
  static const Country R776 =
    Location_Country_R776;
  static const Country R798 =
    Location_Country_R798;
  static const Country R876 =
    Location_Country_R876;
  static inline bool Country_IsValid(int value) {
    return Location_Country_IsValid(value);
  }
  static const Country Country_MIN =
    Location_Country_Country_MIN;
  static const Country Country_MAX =
    Location_Country_Country_MAX;
  static const int Country_ARRAYSIZE =
    Location_Country_Country_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Country_descriptor() {
    return Location_Country_descriptor();
  }
  static inline const ::std::string& Country_Name(Country value) {
    return Location_Country_Name(value);
  }
  static inline bool Country_Parse(const ::std::string& name,
      Country* value) {
    return Location_Country_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // string city = 3;
  void clear_city();
  static const int kCityFieldNumber = 3;
  const ::std::string& city() const;
  void set_city(const ::std::string& value);
  #if LANG_CXX11
  void set_city(::std::string&& value);
  #endif
  void set_city(const char* value);
  void set_city(const char* value, size_t size);
  ::std::string* mutable_city();
  ::std::string* release_city();
  void set_allocated_city(::std::string* city);

  // string code = 4;
  void clear_code();
  static const int kCodeFieldNumber = 4;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // .pb.Location.Country country = 1;
  void clear_country();
  static const int kCountryFieldNumber = 1;
  ::pb::Location_Country country() const;
  void set_country(::pb::Location_Country value);

  // sint32 latitude = 5;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 5;
  ::google::protobuf::int32 latitude() const;
  void set_latitude(::google::protobuf::int32 value);

  // sint32 longitude = 6;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 6;
  ::google::protobuf::int32 longitude() const;
  void set_longitude(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Location)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::google::protobuf::internal::ArenaStringPtr city_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  int country_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::int32 longitude_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Claim

// .pb.Stream stream = 1;
inline bool Claim::has_stream() const {
  return type_case() == kStream;
}
inline void Claim::set_has_stream() {
  _oneof_case_[0] = kStream;
}
inline void Claim::clear_stream() {
  if (has_stream()) {
    delete type_.stream_;
    clear_has_type();
  }
}
inline ::pb::Stream* Claim::release_stream() {
  // @@protoc_insertion_point(field_release:pb.Claim.stream)
  if (has_stream()) {
    clear_has_type();
      ::pb::Stream* temp = type_.stream_;
    type_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Stream& Claim::stream() const {
  // @@protoc_insertion_point(field_get:pb.Claim.stream)
  return has_stream()
      ? *type_.stream_
      : *reinterpret_cast< ::pb::Stream*>(&::pb::_Stream_default_instance_);
}
inline ::pb::Stream* Claim::mutable_stream() {
  if (!has_stream()) {
    clear_type();
    set_has_stream();
    type_.stream_ = CreateMaybeMessage< ::pb::Stream >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pb.Claim.stream)
  return type_.stream_;
}

// .pb.Channel channel = 2;
inline bool Claim::has_channel() const {
  return type_case() == kChannel;
}
inline void Claim::set_has_channel() {
  _oneof_case_[0] = kChannel;
}
inline void Claim::clear_channel() {
  if (has_channel()) {
    delete type_.channel_;
    clear_has_type();
  }
}
inline ::pb::Channel* Claim::release_channel() {
  // @@protoc_insertion_point(field_release:pb.Claim.channel)
  if (has_channel()) {
    clear_has_type();
      ::pb::Channel* temp = type_.channel_;
    type_.channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Channel& Claim::channel() const {
  // @@protoc_insertion_point(field_get:pb.Claim.channel)
  return has_channel()
      ? *type_.channel_
      : *reinterpret_cast< ::pb::Channel*>(&::pb::_Channel_default_instance_);
}
inline ::pb::Channel* Claim::mutable_channel() {
  if (!has_channel()) {
    clear_type();
    set_has_channel();
    type_.channel_ = CreateMaybeMessage< ::pb::Channel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pb.Claim.channel)
  return type_.channel_;
}

// .pb.ClaimList collection = 3;
inline bool Claim::has_collection() const {
  return type_case() == kCollection;
}
inline void Claim::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void Claim::clear_collection() {
  if (has_collection()) {
    delete type_.collection_;
    clear_has_type();
  }
}
inline ::pb::ClaimList* Claim::release_collection() {
  // @@protoc_insertion_point(field_release:pb.Claim.collection)
  if (has_collection()) {
    clear_has_type();
      ::pb::ClaimList* temp = type_.collection_;
    type_.collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::ClaimList& Claim::collection() const {
  // @@protoc_insertion_point(field_get:pb.Claim.collection)
  return has_collection()
      ? *type_.collection_
      : *reinterpret_cast< ::pb::ClaimList*>(&::pb::_ClaimList_default_instance_);
}
inline ::pb::ClaimList* Claim::mutable_collection() {
  if (!has_collection()) {
    clear_type();
    set_has_collection();
    type_.collection_ = CreateMaybeMessage< ::pb::ClaimList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pb.Claim.collection)
  return type_.collection_;
}

// .pb.ClaimReference repost = 4;
inline bool Claim::has_repost() const {
  return type_case() == kRepost;
}
inline void Claim::set_has_repost() {
  _oneof_case_[0] = kRepost;
}
inline void Claim::clear_repost() {
  if (has_repost()) {
    delete type_.repost_;
    clear_has_type();
  }
}
inline ::pb::ClaimReference* Claim::release_repost() {
  // @@protoc_insertion_point(field_release:pb.Claim.repost)
  if (has_repost()) {
    clear_has_type();
      ::pb::ClaimReference* temp = type_.repost_;
    type_.repost_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::ClaimReference& Claim::repost() const {
  // @@protoc_insertion_point(field_get:pb.Claim.repost)
  return has_repost()
      ? *type_.repost_
      : *reinterpret_cast< ::pb::ClaimReference*>(&::pb::_ClaimReference_default_instance_);
}
inline ::pb::ClaimReference* Claim::mutable_repost() {
  if (!has_repost()) {
    clear_type();
    set_has_repost();
    type_.repost_ = CreateMaybeMessage< ::pb::ClaimReference >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pb.Claim.repost)
  return type_.repost_;
}

// string title = 8;
inline void Claim::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Claim::title() const {
  // @@protoc_insertion_point(field_get:pb.Claim.title)
  return title_.GetNoArena();
}
inline void Claim::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Claim.title)
}
#if LANG_CXX11
inline void Claim::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Claim.title)
}
#endif
inline void Claim::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Claim.title)
}
inline void Claim::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Claim.title)
}
inline ::std::string* Claim::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:pb.Claim.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Claim::release_title() {
  // @@protoc_insertion_point(field_release:pb.Claim.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Claim::set_allocated_title(::std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:pb.Claim.title)
}

// string description = 9;
inline void Claim::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Claim::description() const {
  // @@protoc_insertion_point(field_get:pb.Claim.description)
  return description_.GetNoArena();
}
inline void Claim::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Claim.description)
}
#if LANG_CXX11
inline void Claim::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Claim.description)
}
#endif
inline void Claim::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Claim.description)
}
inline void Claim::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Claim.description)
}
inline ::std::string* Claim::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:pb.Claim.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Claim::release_description() {
  // @@protoc_insertion_point(field_release:pb.Claim.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Claim::set_allocated_description(::std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:pb.Claim.description)
}

// .pb.Source thumbnail = 10;
inline bool Claim::has_thumbnail() const {
  return this != internal_default_instance() && thumbnail_ != nullptr;
}
inline void Claim::clear_thumbnail() {
  if (GetArenaNoVirtual() == nullptr && thumbnail_ != nullptr) {
    delete thumbnail_;
  }
  thumbnail_ = nullptr;
}
inline const ::pb::Source& Claim::thumbnail() const {
  const ::pb::Source* p = thumbnail_;
  // @@protoc_insertion_point(field_get:pb.Claim.thumbnail)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::Source*>(
      &::pb::_Source_default_instance_);
}
inline ::pb::Source* Claim::release_thumbnail() {
  // @@protoc_insertion_point(field_release:pb.Claim.thumbnail)
  
  ::pb::Source* temp = thumbnail_;
  thumbnail_ = nullptr;
  return temp;
}
inline ::pb::Source* Claim::mutable_thumbnail() {
  
  if (thumbnail_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Source>(GetArenaNoVirtual());
    thumbnail_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.Claim.thumbnail)
  return thumbnail_;
}
inline void Claim::set_allocated_thumbnail(::pb::Source* thumbnail) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete thumbnail_;
  }
  if (thumbnail) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      thumbnail = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, thumbnail, submessage_arena);
    }
    
  } else {
    
  }
  thumbnail_ = thumbnail;
  // @@protoc_insertion_point(field_set_allocated:pb.Claim.thumbnail)
}

// repeated string tags = 11;
inline int Claim::tags_size() const {
  return tags_.size();
}
inline void Claim::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Claim::tags(int index) const {
  // @@protoc_insertion_point(field_get:pb.Claim.tags)
  return tags_.Get(index);
}
inline ::std::string* Claim::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Claim.tags)
  return tags_.Mutable(index);
}
inline void Claim::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.Claim.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Claim::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.Claim.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Claim::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Claim.tags)
}
inline void Claim::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Claim.tags)
}
inline ::std::string* Claim::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:pb.Claim.tags)
  return tags_.Add();
}
inline void Claim::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.Claim.tags)
}
#if LANG_CXX11
inline void Claim::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.Claim.tags)
}
#endif
inline void Claim::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.Claim.tags)
}
inline void Claim::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.Claim.tags)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Claim::tags() const {
  // @@protoc_insertion_point(field_list:pb.Claim.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Claim::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:pb.Claim.tags)
  return &tags_;
}

// repeated .pb.Language languages = 12;
inline int Claim::languages_size() const {
  return languages_.size();
}
inline void Claim::clear_languages() {
  languages_.Clear();
}
inline ::pb::Language* Claim::mutable_languages(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Claim.languages)
  return languages_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Language >*
Claim::mutable_languages() {
  // @@protoc_insertion_point(field_mutable_list:pb.Claim.languages)
  return &languages_;
}
inline const ::pb::Language& Claim::languages(int index) const {
  // @@protoc_insertion_point(field_get:pb.Claim.languages)
  return languages_.Get(index);
}
inline ::pb::Language* Claim::add_languages() {
  // @@protoc_insertion_point(field_add:pb.Claim.languages)
  return languages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Language >&
Claim::languages() const {
  // @@protoc_insertion_point(field_list:pb.Claim.languages)
  return languages_;
}

// repeated .pb.Location locations = 13;
inline int Claim::locations_size() const {
  return locations_.size();
}
inline void Claim::clear_locations() {
  locations_.Clear();
}
inline ::pb::Location* Claim::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Claim.locations)
  return locations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Location >*
Claim::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:pb.Claim.locations)
  return &locations_;
}
inline const ::pb::Location& Claim::locations(int index) const {
  // @@protoc_insertion_point(field_get:pb.Claim.locations)
  return locations_.Get(index);
}
inline ::pb::Location* Claim::add_locations() {
  // @@protoc_insertion_point(field_add:pb.Claim.locations)
  return locations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Location >&
Claim::locations() const {
  // @@protoc_insertion_point(field_list:pb.Claim.locations)
  return locations_;
}

inline bool Claim::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Claim::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Claim::TypeCase Claim::type_case() const {
  return Claim::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Stream

// .pb.Source source = 1;
inline bool Stream::has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline void Stream::clear_source() {
  if (GetArenaNoVirtual() == nullptr && source_ != nullptr) {
    delete source_;
  }
  source_ = nullptr;
}
inline const ::pb::Source& Stream::source() const {
  const ::pb::Source* p = source_;
  // @@protoc_insertion_point(field_get:pb.Stream.source)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::Source*>(
      &::pb::_Source_default_instance_);
}
inline ::pb::Source* Stream::release_source() {
  // @@protoc_insertion_point(field_release:pb.Stream.source)
  
  ::pb::Source* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::pb::Source* Stream::mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Source>(GetArenaNoVirtual());
    source_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.Stream.source)
  return source_;
}
inline void Stream::set_allocated_source(::pb::Source* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.source)
}

// string author = 2;
inline void Stream::clear_author() {
  author_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::author() const {
  // @@protoc_insertion_point(field_get:pb.Stream.author)
  return author_.GetNoArena();
}
inline void Stream::set_author(const ::std::string& value) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Stream.author)
}
#if LANG_CXX11
inline void Stream::set_author(::std::string&& value) {
  
  author_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.author)
}
#endif
inline void Stream::set_author(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Stream.author)
}
inline void Stream::set_author(const char* value, size_t size) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.author)
}
inline ::std::string* Stream::mutable_author() {
  
  // @@protoc_insertion_point(field_mutable:pb.Stream.author)
  return author_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_author() {
  // @@protoc_insertion_point(field_release:pb.Stream.author)
  
  return author_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_author(::std::string* author) {
  if (author != nullptr) {
    
  } else {
    
  }
  author_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author);
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.author)
}

// string license = 3;
inline void Stream::clear_license() {
  license_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::license() const {
  // @@protoc_insertion_point(field_get:pb.Stream.license)
  return license_.GetNoArena();
}
inline void Stream::set_license(const ::std::string& value) {
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Stream.license)
}
#if LANG_CXX11
inline void Stream::set_license(::std::string&& value) {
  
  license_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.license)
}
#endif
inline void Stream::set_license(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Stream.license)
}
inline void Stream::set_license(const char* value, size_t size) {
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.license)
}
inline ::std::string* Stream::mutable_license() {
  
  // @@protoc_insertion_point(field_mutable:pb.Stream.license)
  return license_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_license() {
  // @@protoc_insertion_point(field_release:pb.Stream.license)
  
  return license_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_license(::std::string* license) {
  if (license != nullptr) {
    
  } else {
    
  }
  license_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license);
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.license)
}

// string license_url = 4;
inline void Stream::clear_license_url() {
  license_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::license_url() const {
  // @@protoc_insertion_point(field_get:pb.Stream.license_url)
  return license_url_.GetNoArena();
}
inline void Stream::set_license_url(const ::std::string& value) {
  
  license_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Stream.license_url)
}
#if LANG_CXX11
inline void Stream::set_license_url(::std::string&& value) {
  
  license_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.license_url)
}
#endif
inline void Stream::set_license_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  license_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Stream.license_url)
}
inline void Stream::set_license_url(const char* value, size_t size) {
  
  license_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.license_url)
}
inline ::std::string* Stream::mutable_license_url() {
  
  // @@protoc_insertion_point(field_mutable:pb.Stream.license_url)
  return license_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_license_url() {
  // @@protoc_insertion_point(field_release:pb.Stream.license_url)
  
  return license_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_license_url(::std::string* license_url) {
  if (license_url != nullptr) {
    
  } else {
    
  }
  license_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license_url);
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.license_url)
}

// int64 release_time = 5;
inline void Stream::clear_release_time() {
  release_time_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Stream::release_time() const {
  // @@protoc_insertion_point(field_get:pb.Stream.release_time)
  return release_time_;
}
inline void Stream::set_release_time(::google::protobuf::int64 value) {
  
  release_time_ = value;
  // @@protoc_insertion_point(field_set:pb.Stream.release_time)
}

// .pb.Fee fee = 6;
inline bool Stream::has_fee() const {
  return this != internal_default_instance() && fee_ != nullptr;
}
inline void Stream::clear_fee() {
  if (GetArenaNoVirtual() == nullptr && fee_ != nullptr) {
    delete fee_;
  }
  fee_ = nullptr;
}
inline const ::pb::Fee& Stream::fee() const {
  const ::pb::Fee* p = fee_;
  // @@protoc_insertion_point(field_get:pb.Stream.fee)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::Fee*>(
      &::pb::_Fee_default_instance_);
}
inline ::pb::Fee* Stream::release_fee() {
  // @@protoc_insertion_point(field_release:pb.Stream.fee)
  
  ::pb::Fee* temp = fee_;
  fee_ = nullptr;
  return temp;
}
inline ::pb::Fee* Stream::mutable_fee() {
  
  if (fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Fee>(GetArenaNoVirtual());
    fee_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.Stream.fee)
  return fee_;
}
inline void Stream::set_allocated_fee(::pb::Fee* fee) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fee_;
  }
  if (fee) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fee = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    
  } else {
    
  }
  fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.fee)
}

// .pb.Image image = 10;
inline bool Stream::has_image() const {
  return type_case() == kImage;
}
inline void Stream::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void Stream::clear_image() {
  if (has_image()) {
    delete type_.image_;
    clear_has_type();
  }
}
inline ::pb::Image* Stream::release_image() {
  // @@protoc_insertion_point(field_release:pb.Stream.image)
  if (has_image()) {
    clear_has_type();
      ::pb::Image* temp = type_.image_;
    type_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Image& Stream::image() const {
  // @@protoc_insertion_point(field_get:pb.Stream.image)
  return has_image()
      ? *type_.image_
      : *reinterpret_cast< ::pb::Image*>(&::pb::_Image_default_instance_);
}
inline ::pb::Image* Stream::mutable_image() {
  if (!has_image()) {
    clear_type();
    set_has_image();
    type_.image_ = CreateMaybeMessage< ::pb::Image >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pb.Stream.image)
  return type_.image_;
}

// .pb.Video video = 11;
inline bool Stream::has_video() const {
  return type_case() == kVideo;
}
inline void Stream::set_has_video() {
  _oneof_case_[0] = kVideo;
}
inline void Stream::clear_video() {
  if (has_video()) {
    delete type_.video_;
    clear_has_type();
  }
}
inline ::pb::Video* Stream::release_video() {
  // @@protoc_insertion_point(field_release:pb.Stream.video)
  if (has_video()) {
    clear_has_type();
      ::pb::Video* temp = type_.video_;
    type_.video_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Video& Stream::video() const {
  // @@protoc_insertion_point(field_get:pb.Stream.video)
  return has_video()
      ? *type_.video_
      : *reinterpret_cast< ::pb::Video*>(&::pb::_Video_default_instance_);
}
inline ::pb::Video* Stream::mutable_video() {
  if (!has_video()) {
    clear_type();
    set_has_video();
    type_.video_ = CreateMaybeMessage< ::pb::Video >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pb.Stream.video)
  return type_.video_;
}

// .pb.Audio audio = 12;
inline bool Stream::has_audio() const {
  return type_case() == kAudio;
}
inline void Stream::set_has_audio() {
  _oneof_case_[0] = kAudio;
}
inline void Stream::clear_audio() {
  if (has_audio()) {
    delete type_.audio_;
    clear_has_type();
  }
}
inline ::pb::Audio* Stream::release_audio() {
  // @@protoc_insertion_point(field_release:pb.Stream.audio)
  if (has_audio()) {
    clear_has_type();
      ::pb::Audio* temp = type_.audio_;
    type_.audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Audio& Stream::audio() const {
  // @@protoc_insertion_point(field_get:pb.Stream.audio)
  return has_audio()
      ? *type_.audio_
      : *reinterpret_cast< ::pb::Audio*>(&::pb::_Audio_default_instance_);
}
inline ::pb::Audio* Stream::mutable_audio() {
  if (!has_audio()) {
    clear_type();
    set_has_audio();
    type_.audio_ = CreateMaybeMessage< ::pb::Audio >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pb.Stream.audio)
  return type_.audio_;
}

// .pb.Software software = 13;
inline bool Stream::has_software() const {
  return type_case() == kSoftware;
}
inline void Stream::set_has_software() {
  _oneof_case_[0] = kSoftware;
}
inline void Stream::clear_software() {
  if (has_software()) {
    delete type_.software_;
    clear_has_type();
  }
}
inline ::pb::Software* Stream::release_software() {
  // @@protoc_insertion_point(field_release:pb.Stream.software)
  if (has_software()) {
    clear_has_type();
      ::pb::Software* temp = type_.software_;
    type_.software_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Software& Stream::software() const {
  // @@protoc_insertion_point(field_get:pb.Stream.software)
  return has_software()
      ? *type_.software_
      : *reinterpret_cast< ::pb::Software*>(&::pb::_Software_default_instance_);
}
inline ::pb::Software* Stream::mutable_software() {
  if (!has_software()) {
    clear_type();
    set_has_software();
    type_.software_ = CreateMaybeMessage< ::pb::Software >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pb.Stream.software)
  return type_.software_;
}

inline bool Stream::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Stream::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Stream::TypeCase Stream::type_case() const {
  return Stream::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Channel

// bytes public_key = 1;
inline void Channel::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::public_key() const {
  // @@protoc_insertion_point(field_get:pb.Channel.public_key)
  return public_key_.GetNoArena();
}
inline void Channel::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Channel.public_key)
}
#if LANG_CXX11
inline void Channel::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.public_key)
}
#endif
inline void Channel::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Channel.public_key)
}
inline void Channel::set_public_key(const void* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.public_key)
}
inline ::std::string* Channel::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:pb.Channel.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_public_key() {
  // @@protoc_insertion_point(field_release:pb.Channel.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_public_key(::std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.public_key)
}

// string email = 2;
inline void Channel::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::email() const {
  // @@protoc_insertion_point(field_get:pb.Channel.email)
  return email_.GetNoArena();
}
inline void Channel::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Channel.email)
}
#if LANG_CXX11
inline void Channel::set_email(::std::string&& value) {
  
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.email)
}
#endif
inline void Channel::set_email(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Channel.email)
}
inline void Channel::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.email)
}
inline ::std::string* Channel::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:pb.Channel.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_email() {
  // @@protoc_insertion_point(field_release:pb.Channel.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_email(::std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.email)
}

// string website_url = 3;
inline void Channel::clear_website_url() {
  website_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::website_url() const {
  // @@protoc_insertion_point(field_get:pb.Channel.website_url)
  return website_url_.GetNoArena();
}
inline void Channel::set_website_url(const ::std::string& value) {
  
  website_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Channel.website_url)
}
#if LANG_CXX11
inline void Channel::set_website_url(::std::string&& value) {
  
  website_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.website_url)
}
#endif
inline void Channel::set_website_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  website_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Channel.website_url)
}
inline void Channel::set_website_url(const char* value, size_t size) {
  
  website_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.website_url)
}
inline ::std::string* Channel::mutable_website_url() {
  
  // @@protoc_insertion_point(field_mutable:pb.Channel.website_url)
  return website_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_website_url() {
  // @@protoc_insertion_point(field_release:pb.Channel.website_url)
  
  return website_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_website_url(::std::string* website_url) {
  if (website_url != nullptr) {
    
  } else {
    
  }
  website_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), website_url);
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.website_url)
}

// .pb.Source cover = 4;
inline bool Channel::has_cover() const {
  return this != internal_default_instance() && cover_ != nullptr;
}
inline void Channel::clear_cover() {
  if (GetArenaNoVirtual() == nullptr && cover_ != nullptr) {
    delete cover_;
  }
  cover_ = nullptr;
}
inline const ::pb::Source& Channel::cover() const {
  const ::pb::Source* p = cover_;
  // @@protoc_insertion_point(field_get:pb.Channel.cover)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::Source*>(
      &::pb::_Source_default_instance_);
}
inline ::pb::Source* Channel::release_cover() {
  // @@protoc_insertion_point(field_release:pb.Channel.cover)
  
  ::pb::Source* temp = cover_;
  cover_ = nullptr;
  return temp;
}
inline ::pb::Source* Channel::mutable_cover() {
  
  if (cover_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Source>(GetArenaNoVirtual());
    cover_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.Channel.cover)
  return cover_;
}
inline void Channel::set_allocated_cover(::pb::Source* cover) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cover_;
  }
  if (cover) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cover = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cover, submessage_arena);
    }
    
  } else {
    
  }
  cover_ = cover;
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.cover)
}

// .pb.ClaimList featured = 5;
inline bool Channel::has_featured() const {
  return this != internal_default_instance() && featured_ != nullptr;
}
inline void Channel::clear_featured() {
  if (GetArenaNoVirtual() == nullptr && featured_ != nullptr) {
    delete featured_;
  }
  featured_ = nullptr;
}
inline const ::pb::ClaimList& Channel::featured() const {
  const ::pb::ClaimList* p = featured_;
  // @@protoc_insertion_point(field_get:pb.Channel.featured)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::ClaimList*>(
      &::pb::_ClaimList_default_instance_);
}
inline ::pb::ClaimList* Channel::release_featured() {
  // @@protoc_insertion_point(field_release:pb.Channel.featured)
  
  ::pb::ClaimList* temp = featured_;
  featured_ = nullptr;
  return temp;
}
inline ::pb::ClaimList* Channel::mutable_featured() {
  
  if (featured_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::ClaimList>(GetArenaNoVirtual());
    featured_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.Channel.featured)
  return featured_;
}
inline void Channel::set_allocated_featured(::pb::ClaimList* featured) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete featured_;
  }
  if (featured) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      featured = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, featured, submessage_arena);
    }
    
  } else {
    
  }
  featured_ = featured;
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.featured)
}

// -------------------------------------------------------------------

// ClaimReference

// bytes claim_hash = 1;
inline void ClaimReference::clear_claim_hash() {
  claim_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClaimReference::claim_hash() const {
  // @@protoc_insertion_point(field_get:pb.ClaimReference.claim_hash)
  return claim_hash_.GetNoArena();
}
inline void ClaimReference::set_claim_hash(const ::std::string& value) {
  
  claim_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.ClaimReference.claim_hash)
}
#if LANG_CXX11
inline void ClaimReference::set_claim_hash(::std::string&& value) {
  
  claim_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.ClaimReference.claim_hash)
}
#endif
inline void ClaimReference::set_claim_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  claim_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.ClaimReference.claim_hash)
}
inline void ClaimReference::set_claim_hash(const void* value, size_t size) {
  
  claim_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.ClaimReference.claim_hash)
}
inline ::std::string* ClaimReference::mutable_claim_hash() {
  
  // @@protoc_insertion_point(field_mutable:pb.ClaimReference.claim_hash)
  return claim_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClaimReference::release_claim_hash() {
  // @@protoc_insertion_point(field_release:pb.ClaimReference.claim_hash)
  
  return claim_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClaimReference::set_allocated_claim_hash(::std::string* claim_hash) {
  if (claim_hash != nullptr) {
    
  } else {
    
  }
  claim_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), claim_hash);
  // @@protoc_insertion_point(field_set_allocated:pb.ClaimReference.claim_hash)
}

// -------------------------------------------------------------------

// ClaimList

// .pb.ClaimList.ListType list_type = 1;
inline void ClaimList::clear_list_type() {
  list_type_ = 0;
}
inline ::pb::ClaimList_ListType ClaimList::list_type() const {
  // @@protoc_insertion_point(field_get:pb.ClaimList.list_type)
  return static_cast< ::pb::ClaimList_ListType >(list_type_);
}
inline void ClaimList::set_list_type(::pb::ClaimList_ListType value) {
  
  list_type_ = value;
  // @@protoc_insertion_point(field_set:pb.ClaimList.list_type)
}

// repeated .pb.ClaimReference claim_references = 2;
inline int ClaimList::claim_references_size() const {
  return claim_references_.size();
}
inline void ClaimList::clear_claim_references() {
  claim_references_.Clear();
}
inline ::pb::ClaimReference* ClaimList::mutable_claim_references(int index) {
  // @@protoc_insertion_point(field_mutable:pb.ClaimList.claim_references)
  return claim_references_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ClaimReference >*
ClaimList::mutable_claim_references() {
  // @@protoc_insertion_point(field_mutable_list:pb.ClaimList.claim_references)
  return &claim_references_;
}
inline const ::pb::ClaimReference& ClaimList::claim_references(int index) const {
  // @@protoc_insertion_point(field_get:pb.ClaimList.claim_references)
  return claim_references_.Get(index);
}
inline ::pb::ClaimReference* ClaimList::add_claim_references() {
  // @@protoc_insertion_point(field_add:pb.ClaimList.claim_references)
  return claim_references_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ClaimReference >&
ClaimList::claim_references() const {
  // @@protoc_insertion_point(field_list:pb.ClaimList.claim_references)
  return claim_references_;
}

// -------------------------------------------------------------------

// Source

// bytes hash = 1;
inline void Source::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Source::hash() const {
  // @@protoc_insertion_point(field_get:pb.Source.hash)
  return hash_.GetNoArena();
}
inline void Source::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Source.hash)
}
#if LANG_CXX11
inline void Source::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.hash)
}
#endif
inline void Source::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Source.hash)
}
inline void Source::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Source.hash)
}
inline ::std::string* Source::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:pb.Source.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Source::release_hash() {
  // @@protoc_insertion_point(field_release:pb.Source.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Source::set_allocated_hash(::std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:pb.Source.hash)
}

// string name = 2;
inline void Source::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Source::name() const {
  // @@protoc_insertion_point(field_get:pb.Source.name)
  return name_.GetNoArena();
}
inline void Source::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Source.name)
}
#if LANG_CXX11
inline void Source::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.name)
}
#endif
inline void Source::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Source.name)
}
inline void Source::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Source.name)
}
inline ::std::string* Source::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:pb.Source.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Source::release_name() {
  // @@protoc_insertion_point(field_release:pb.Source.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Source::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pb.Source.name)
}

// uint64 size = 3;
inline void Source::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Source::size() const {
  // @@protoc_insertion_point(field_get:pb.Source.size)
  return size_;
}
inline void Source::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:pb.Source.size)
}

// string media_type = 4;
inline void Source::clear_media_type() {
  media_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Source::media_type() const {
  // @@protoc_insertion_point(field_get:pb.Source.media_type)
  return media_type_.GetNoArena();
}
inline void Source::set_media_type(const ::std::string& value) {
  
  media_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Source.media_type)
}
#if LANG_CXX11
inline void Source::set_media_type(::std::string&& value) {
  
  media_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.media_type)
}
#endif
inline void Source::set_media_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  media_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Source.media_type)
}
inline void Source::set_media_type(const char* value, size_t size) {
  
  media_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Source.media_type)
}
inline ::std::string* Source::mutable_media_type() {
  
  // @@protoc_insertion_point(field_mutable:pb.Source.media_type)
  return media_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Source::release_media_type() {
  // @@protoc_insertion_point(field_release:pb.Source.media_type)
  
  return media_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Source::set_allocated_media_type(::std::string* media_type) {
  if (media_type != nullptr) {
    
  } else {
    
  }
  media_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), media_type);
  // @@protoc_insertion_point(field_set_allocated:pb.Source.media_type)
}

// string url = 5;
inline void Source::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Source::url() const {
  // @@protoc_insertion_point(field_get:pb.Source.url)
  return url_.GetNoArena();
}
inline void Source::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Source.url)
}
#if LANG_CXX11
inline void Source::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.url)
}
#endif
inline void Source::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Source.url)
}
inline void Source::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Source.url)
}
inline ::std::string* Source::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:pb.Source.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Source::release_url() {
  // @@protoc_insertion_point(field_release:pb.Source.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Source::set_allocated_url(::std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:pb.Source.url)
}

// bytes sd_hash = 6;
inline void Source::clear_sd_hash() {
  sd_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Source::sd_hash() const {
  // @@protoc_insertion_point(field_get:pb.Source.sd_hash)
  return sd_hash_.GetNoArena();
}
inline void Source::set_sd_hash(const ::std::string& value) {
  
  sd_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Source.sd_hash)
}
#if LANG_CXX11
inline void Source::set_sd_hash(::std::string&& value) {
  
  sd_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.sd_hash)
}
#endif
inline void Source::set_sd_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sd_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Source.sd_hash)
}
inline void Source::set_sd_hash(const void* value, size_t size) {
  
  sd_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Source.sd_hash)
}
inline ::std::string* Source::mutable_sd_hash() {
  
  // @@protoc_insertion_point(field_mutable:pb.Source.sd_hash)
  return sd_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Source::release_sd_hash() {
  // @@protoc_insertion_point(field_release:pb.Source.sd_hash)
  
  return sd_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Source::set_allocated_sd_hash(::std::string* sd_hash) {
  if (sd_hash != nullptr) {
    
  } else {
    
  }
  sd_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sd_hash);
  // @@protoc_insertion_point(field_set_allocated:pb.Source.sd_hash)
}

// bytes bt_infohash = 7;
inline void Source::clear_bt_infohash() {
  bt_infohash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Source::bt_infohash() const {
  // @@protoc_insertion_point(field_get:pb.Source.bt_infohash)
  return bt_infohash_.GetNoArena();
}
inline void Source::set_bt_infohash(const ::std::string& value) {
  
  bt_infohash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Source.bt_infohash)
}
#if LANG_CXX11
inline void Source::set_bt_infohash(::std::string&& value) {
  
  bt_infohash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.bt_infohash)
}
#endif
inline void Source::set_bt_infohash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  bt_infohash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Source.bt_infohash)
}
inline void Source::set_bt_infohash(const void* value, size_t size) {
  
  bt_infohash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Source.bt_infohash)
}
inline ::std::string* Source::mutable_bt_infohash() {
  
  // @@protoc_insertion_point(field_mutable:pb.Source.bt_infohash)
  return bt_infohash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Source::release_bt_infohash() {
  // @@protoc_insertion_point(field_release:pb.Source.bt_infohash)
  
  return bt_infohash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Source::set_allocated_bt_infohash(::std::string* bt_infohash) {
  if (bt_infohash != nullptr) {
    
  } else {
    
  }
  bt_infohash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bt_infohash);
  // @@protoc_insertion_point(field_set_allocated:pb.Source.bt_infohash)
}

// -------------------------------------------------------------------

// Fee

// .pb.Fee.Currency currency = 1;
inline void Fee::clear_currency() {
  currency_ = 0;
}
inline ::pb::Fee_Currency Fee::currency() const {
  // @@protoc_insertion_point(field_get:pb.Fee.currency)
  return static_cast< ::pb::Fee_Currency >(currency_);
}
inline void Fee::set_currency(::pb::Fee_Currency value) {
  
  currency_ = value;
  // @@protoc_insertion_point(field_set:pb.Fee.currency)
}

// bytes address = 2;
inline void Fee::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fee::address() const {
  // @@protoc_insertion_point(field_get:pb.Fee.address)
  return address_.GetNoArena();
}
inline void Fee::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Fee.address)
}
#if LANG_CXX11
inline void Fee::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Fee.address)
}
#endif
inline void Fee::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Fee.address)
}
inline void Fee::set_address(const void* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Fee.address)
}
inline ::std::string* Fee::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:pb.Fee.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fee::release_address() {
  // @@protoc_insertion_point(field_release:pb.Fee.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fee::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:pb.Fee.address)
}

// uint64 amount = 3;
inline void Fee::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Fee::amount() const {
  // @@protoc_insertion_point(field_get:pb.Fee.amount)
  return amount_;
}
inline void Fee::set_amount(::google::protobuf::uint64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:pb.Fee.amount)
}

// -------------------------------------------------------------------

// Image

// uint32 width = 1;
inline void Image::clear_width() {
  width_ = 0u;
}
inline ::google::protobuf::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:pb.Image.width)
  return width_;
}
inline void Image::set_width(::google::protobuf::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:pb.Image.width)
}

// uint32 height = 2;
inline void Image::clear_height() {
  height_ = 0u;
}
inline ::google::protobuf::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:pb.Image.height)
  return height_;
}
inline void Image::set_height(::google::protobuf::uint32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:pb.Image.height)
}

// -------------------------------------------------------------------

// Video

// uint32 width = 1;
inline void Video::clear_width() {
  width_ = 0u;
}
inline ::google::protobuf::uint32 Video::width() const {
  // @@protoc_insertion_point(field_get:pb.Video.width)
  return width_;
}
inline void Video::set_width(::google::protobuf::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:pb.Video.width)
}

// uint32 height = 2;
inline void Video::clear_height() {
  height_ = 0u;
}
inline ::google::protobuf::uint32 Video::height() const {
  // @@protoc_insertion_point(field_get:pb.Video.height)
  return height_;
}
inline void Video::set_height(::google::protobuf::uint32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:pb.Video.height)
}

// uint32 duration = 3;
inline void Video::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 Video::duration() const {
  // @@protoc_insertion_point(field_get:pb.Video.duration)
  return duration_;
}
inline void Video::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:pb.Video.duration)
}

// .pb.Audio audio = 15;
inline bool Video::has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline void Video::clear_audio() {
  if (GetArenaNoVirtual() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::pb::Audio& Video::audio() const {
  const ::pb::Audio* p = audio_;
  // @@protoc_insertion_point(field_get:pb.Video.audio)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::Audio*>(
      &::pb::_Audio_default_instance_);
}
inline ::pb::Audio* Video::release_audio() {
  // @@protoc_insertion_point(field_release:pb.Video.audio)
  
  ::pb::Audio* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::pb::Audio* Video::mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Audio>(GetArenaNoVirtual());
    audio_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.Video.audio)
  return audio_;
}
inline void Video::set_allocated_audio(::pb::Audio* audio) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      audio = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:pb.Video.audio)
}

// -------------------------------------------------------------------

// Audio

// uint32 duration = 1;
inline void Audio::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 Audio::duration() const {
  // @@protoc_insertion_point(field_get:pb.Audio.duration)
  return duration_;
}
inline void Audio::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:pb.Audio.duration)
}

// -------------------------------------------------------------------

// Software

// string os = 1;
inline void Software::clear_os() {
  os_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Software::os() const {
  // @@protoc_insertion_point(field_get:pb.Software.os)
  return os_.GetNoArena();
}
inline void Software::set_os(const ::std::string& value) {
  
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Software.os)
}
#if LANG_CXX11
inline void Software::set_os(::std::string&& value) {
  
  os_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Software.os)
}
#endif
inline void Software::set_os(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Software.os)
}
inline void Software::set_os(const char* value, size_t size) {
  
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Software.os)
}
inline ::std::string* Software::mutable_os() {
  
  // @@protoc_insertion_point(field_mutable:pb.Software.os)
  return os_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Software::release_os() {
  // @@protoc_insertion_point(field_release:pb.Software.os)
  
  return os_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Software::set_allocated_os(::std::string* os) {
  if (os != nullptr) {
    
  } else {
    
  }
  os_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os);
  // @@protoc_insertion_point(field_set_allocated:pb.Software.os)
}

// -------------------------------------------------------------------

// Language

// .pb.Language.Language language = 1;
inline void Language::clear_language() {
  language_ = 0;
}
inline ::pb::Language_Language Language::language() const {
  // @@protoc_insertion_point(field_get:pb.Language.language)
  return static_cast< ::pb::Language_Language >(language_);
}
inline void Language::set_language(::pb::Language_Language value) {
  
  language_ = value;
  // @@protoc_insertion_point(field_set:pb.Language.language)
}

// .pb.Language.Script script = 2;
inline void Language::clear_script() {
  script_ = 0;
}
inline ::pb::Language_Script Language::script() const {
  // @@protoc_insertion_point(field_get:pb.Language.script)
  return static_cast< ::pb::Language_Script >(script_);
}
inline void Language::set_script(::pb::Language_Script value) {
  
  script_ = value;
  // @@protoc_insertion_point(field_set:pb.Language.script)
}

// .pb.Location.Country region = 3;
inline void Language::clear_region() {
  region_ = 0;
}
inline ::pb::Location_Country Language::region() const {
  // @@protoc_insertion_point(field_get:pb.Language.region)
  return static_cast< ::pb::Location_Country >(region_);
}
inline void Language::set_region(::pb::Location_Country value) {
  
  region_ = value;
  // @@protoc_insertion_point(field_set:pb.Language.region)
}

// -------------------------------------------------------------------

// Location

// .pb.Location.Country country = 1;
inline void Location::clear_country() {
  country_ = 0;
}
inline ::pb::Location_Country Location::country() const {
  // @@protoc_insertion_point(field_get:pb.Location.country)
  return static_cast< ::pb::Location_Country >(country_);
}
inline void Location::set_country(::pb::Location_Country value) {
  
  country_ = value;
  // @@protoc_insertion_point(field_set:pb.Location.country)
}

// string state = 2;
inline void Location::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Location::state() const {
  // @@protoc_insertion_point(field_get:pb.Location.state)
  return state_.GetNoArena();
}
inline void Location::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Location.state)
}
#if LANG_CXX11
inline void Location::set_state(::std::string&& value) {
  
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Location.state)
}
#endif
inline void Location::set_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Location.state)
}
inline void Location::set_state(const char* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Location.state)
}
inline ::std::string* Location::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:pb.Location.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Location::release_state() {
  // @@protoc_insertion_point(field_release:pb.Location.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location::set_allocated_state(::std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:pb.Location.state)
}

// string city = 3;
inline void Location::clear_city() {
  city_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Location::city() const {
  // @@protoc_insertion_point(field_get:pb.Location.city)
  return city_.GetNoArena();
}
inline void Location::set_city(const ::std::string& value) {
  
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Location.city)
}
#if LANG_CXX11
inline void Location::set_city(::std::string&& value) {
  
  city_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Location.city)
}
#endif
inline void Location::set_city(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Location.city)
}
inline void Location::set_city(const char* value, size_t size) {
  
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Location.city)
}
inline ::std::string* Location::mutable_city() {
  
  // @@protoc_insertion_point(field_mutable:pb.Location.city)
  return city_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Location::release_city() {
  // @@protoc_insertion_point(field_release:pb.Location.city)
  
  return city_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location::set_allocated_city(::std::string* city) {
  if (city != nullptr) {
    
  } else {
    
  }
  city_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), city);
  // @@protoc_insertion_point(field_set_allocated:pb.Location.city)
}

// string code = 4;
inline void Location::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Location::code() const {
  // @@protoc_insertion_point(field_get:pb.Location.code)
  return code_.GetNoArena();
}
inline void Location::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Location.code)
}
#if LANG_CXX11
inline void Location::set_code(::std::string&& value) {
  
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Location.code)
}
#endif
inline void Location::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Location.code)
}
inline void Location::set_code(const char* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Location.code)
}
inline ::std::string* Location::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:pb.Location.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Location::release_code() {
  // @@protoc_insertion_point(field_release:pb.Location.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location::set_allocated_code(::std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:pb.Location.code)
}

// sint32 latitude = 5;
inline void Location::clear_latitude() {
  latitude_ = 0;
}
inline ::google::protobuf::int32 Location::latitude() const {
  // @@protoc_insertion_point(field_get:pb.Location.latitude)
  return latitude_;
}
inline void Location::set_latitude(::google::protobuf::int32 value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:pb.Location.latitude)
}

// sint32 longitude = 6;
inline void Location::clear_longitude() {
  longitude_ = 0;
}
inline ::google::protobuf::int32 Location::longitude() const {
  // @@protoc_insertion_point(field_get:pb.Location.longitude)
  return longitude_;
}
inline void Location::set_longitude(::google::protobuf::int32 value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:pb.Location.longitude)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::ClaimList_ListType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ClaimList_ListType>() {
  return ::pb::ClaimList_ListType_descriptor();
}
template <> struct is_proto_enum< ::pb::Fee_Currency> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Fee_Currency>() {
  return ::pb::Fee_Currency_descriptor();
}
template <> struct is_proto_enum< ::pb::Software_OS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Software_OS>() {
  return ::pb::Software_OS_descriptor();
}
template <> struct is_proto_enum< ::pb::Language_Language> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Language_Language>() {
  return ::pb::Language_Language_descriptor();
}
template <> struct is_proto_enum< ::pb::Language_Script> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Language_Script>() {
  return ::pb::Language_Script_descriptor();
}
template <> struct is_proto_enum< ::pb::Location_Country> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Location_Country>() {
  return ::pb::Location_Country_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_claim_2eproto
